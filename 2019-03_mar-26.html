<!doctype html>
<meta charset="utf-8">
<link rel="apple-touch-icon" sizes="180x180" href="img/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="img/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="img/favicon-16x16.png">
<link rel="manifest" href="img/site.webmanifest">
<link rel="mask-icon" href="img/safari-pinned-tab.svg" color="#5bbad5">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/2.6.0/github-markdown.css" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github-gist.min.css" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/javascript.min.js"></script>
<title>March 26, 2019 Meeting Notes</title>
<body class="markdown-body">
<a href="javascript:history.back()">Back</a>
<a href="#march-26-2019-meeting-notes"><h1 id="march-26-2019-meeting-notes">March 26, 2019 Meeting Notes</h1></a><hr>
<p>Istvan Sebestyen (IS), Kevin Smith (KS), Adam Klein (AK), Leo Balter (LBR), Richard Gibson (RGN), Yehuda Katz (YK), Godfrey Chan (GCN), Philipp Dunkel (PDL), Brian Terlson (BT), Aki Rose (AKI), Michael Ficarra (MF), Chip Morningstar (CM), Waldemar Horwat (WH), Kat Marchán (KZM), Tierney Cyren (TCN), Shelley Vohr (SVR), Myles Borins (MBS), Jordan Harband (JHD), Mathias Bynens (MB), Pieter Ouwerkerk (POK), Randy Luecke (RCL), Daniel Ehrenberg (DE), Mike Samuel (MSL), Qiuyi Zhang (QZG), Till Schneidereit (TST), Shane Carr (SFC), Patrick Soquet (PST), Peter Hoddie (PHE), Kyle Verrier (KV), Mattijs Hoitink (MHK), Keith Miller (KM), Michael Saboff (MS), Jordan Gensler (JGR), Mark Miller (MM), Joshua Peek (JPK), Mu-an Chiou (MCU), Guilherme Hermeto (GHO), Sathya Gunasekaran (SGN), Felipe Balbontín (FBN), Jory Burson (JBR), Shu-yu Guo (SYG), Joe Sepi (JSI), Chris Hyle (CHE), Justin Ridgewell (JRL), Rob Palmer (RPR), Keith Cirkel (KCL), Robert Pamely (RPY), Henry Zhu (HZU), Daniel Rosenwasser (DRR), Caridy Patiño (CP), Diego Ferreiro (DF), Domenic Denicola (DD)</p>
<p>Remote:
Ron Buckton (RBN), Kevin Gibbons (KG), Gus Caplan (GCN), Valerie Young (VYG), John-David Dalton (JDD), Gabriel McAdams (GMS)</p>
<hr>
<a href="#agenda"><h2 id="agenda">Agenda</h2></a><ul>
<li><a href="https://github.com/tc39/agendas/blob/master/2019/03.md">Agenda</a></li>
</ul>
<a href="#1-welcome"><h2 id="1-welcome">1. Welcome</h2></a><p>MBS: (welcome)</p>
<p>JHD: If your proposal is Stage 1 or higher, move it to the tc39 organization on GitHub. Follow the instructions to transfer the repo to the org on <a href="https://github.com/tc39/proposals">https://github.com/tc39/proposals</a></p>
<p>AKI: Ping me on IRC if you need help.</p>
<a href="#3-agenda-scheduling"><h2 id="3-agenda-scheduling">3. Agenda Scheduling</h2></a><p>BT: Shall we adopt the agenda?</p>
<a href="#conclusionresolution-3-agenda-scheduling"><h4 id="conclusionresolution-3-agenda-scheduling">Conclusion/Resolution</h4></a><ul>
<li>no objections</li>
</ul>
<a href="#4-approval-of-the-minutes-from-last-meeting"><h2 id="4-approval-of-the-minutes-from-last-meeting">4. Approval of the minutes from last meeting</h2></a><p>BT: Shall we approve the minutes from last meeting?</p>
<a href="#conclusionresolution-4-approval-of-the-minutes-from-last-meeting"><h4 id="conclusionresolution-4-approval-of-the-minutes-from-last-meeting">Conclusion/Resolution</h4></a><ul>
<li>no objections</li>
</ul>
<a href="#5-next-meeting-host-and-logistics"><h2 id="5-next-meeting-host-and-logistics">5. Next meeting host and logistics</h2></a><p>PO: We are hosting the meeting in Berlin in June. Details in the reflector, issue <a href="https://github.com/tc39/Reflector/issues/216">#216</a>. I am seeking help with community events.</p>
<a href="#6-report-from-the-ecma-secretariat"><h2 id="6-report-from-the-ecma-secretariat">6. Report from the Ecma Secretariat</h2></a><p>(Istvan Sebestyen (IS))</p>
<ul>
<li><a href="https://github.com/tc39/Reflector/files/2999399/tc39-2019-016.pdf">slides</a></li>
</ul>
<p>IS: (presents slides)</p>
<p>IS: I propose to close the transition period to RFTC at the end of this meeting.</p>
<p>IS: I propose the following structure: TC39 plenary, TC39-TG1 (for General EcmaScript Language), TC39-TG2 (for Intl/ECMA-402). (reads the rest from slide 11-15)</p>
<p>SFC: On the subject of forming this TG, this document is to formalize what we've been doing for a number of years. DE, is there anything you'd like to add?</p>
<p>DE: I'm very happy with the work you've done here.</p>
<p>WH: Who are the participants in TG2?</p>
<p>IS: Anybody who signs up can choose to join which part of TC39 they join. By the way, we are also in discussions with potential new member from a very large Chinese company, who are - among others - very interested in TG2's work for obvious reasons.</p>
<p>WH: But who are actually the participants here?</p>
<p>SFC: At last month's meeting, we had 18 participants. Many of whom are in this room. Do you want me to read the attendee list? The notes are about to be published.</p>
<p>DE: We have generally similar membership practices to TC39. Some attendees were invited guests, just as on TC39. Notes are published to ECMA-402 repo. We're open to publish in alternative locations, if there's interest in that.</p>
<p><a href="https://github.com/tc39/ecma402/tree/master/meetings">Current Notes Location</a></p>
<p>IS: Meeting minutes are required to be recorded as per Ecma regulations. Generally becoming a TG has also the advantage that there are clear rules for presenting a TG's work. Are there any objections to the TG formation? I see no objections, so we will consider this approved. SFC has been elected the chairman (&quot;convener&quot;) of the TG. (round of applause and also SFC nods)</p>
<p>IS: (continues from slide 17)</p>
<p>IS: Just a reminder, there is a possibility for TC39 to nominate candidates for the Ecma Fellow (More &quot;lifetime achievements&quot;) and Ecma Recognition Award (more for a concrete present time outstanding work) nominees for the June 2019 Ecma GA. Of course that is an ongoing activity also for the next GAs.</p>
<p>CM: Can you discuss the secretariat transition?</p>
<p>IS: We have de-facto not started yet. It is in progress. For the next few months I am still the secretariat.</p>
<p>AKI: Thanks for the update, IS.</p>
<a href="#ecma-262-status-updates"><h2 id="ecma-262-status-updates">ECMA-262 Status Updates</h2></a><p>(Jordan Harband (JHD))</p>
<p>JHD: We've cut the 2019 specification. BT is winding down his editor role and has been passing PRs to JHD and KS. We have not merged PRs because we want to reduce merge conflicts with ES2019. By the May meeting, we will resume accepting PRs. If you have a strong opinion we can merge the PRs sooner.</p>
<p>DE: Why is the practice of merging PRs changed from previous years?</p>
<p>JHD: In previous years, there was more willingness to pull in any non-normative changes into master. There were also fewer large editorial changes. This year, there's just a lot more changes coming in, so we're a lot more hesitant about it. Almost everything that landed during the 2018 opt-out period was back-ported into 2018.</p>
<p>DE: There are conversations we've been having on GitHub about best practices for PRs. It would be great if the editorial board could document that and help come up with best practices.</p>
<p>JHD: This is definitely something we plan to do.</p>
<a href="#ecma-402-updates"><h2 id="ecma-402-updates">ECMA-402 Updates</h2></a><p>(Shane Carr (SFC))</p>
<p>SFC: (Presents slides) (Presents all stage 1-3 proposals). <a href="mailto:ecma402-admin@chromium.org">ecma402-admin@chromium.org</a> is the new alias.</p>
<p>AK: What is the process for stage 3 proposals that introduce major changes?</p>
<p>SFC: For example, in segmenter, which had a major API change, our process has been to iterate over what this process looks like.</p>
<p>DE: segmenter isn't the only time, there were also changes to relative time format at Stage 3. We've tried to discuss in a very open way in ECMA-402 and also in plenary here. I think after some experience, going up and down stages isn't always productive. We all want things to happen, and we want to work out the details with more stakeholders as time goes on. If the committee has more feedback about how we can work out process improvements, we'd love to hear them.</p>
<p>LBR: (Presents slides on Editorship) <a href="https://docs.google.com/presentation/d/1D2vP7GMknBFaXkuBteCLk5bhL-PN_j7z2yK4MmmfYnE/edit#slide=id.p">Editorship slides</a></p>
<p>LBR: Do we have consensus to adopt the proposed editorship group?</p>
<a href="#conclusionresolution-ecma-402-updates"><h4 id="conclusionresolution-ecma-402-updates">Conclusion/Resolution</h4></a><ul>
<li>no objections</li>
</ul>
<a href="#committee-updates"><h2 id="committee-updates">Committee Updates</h2></a><a href="#test262-updates"><h3 id="test262-updates">Test262 Updates</h3></a><p>(Leo Balter (LBR))</p>
<p>LBR: We're now using Test262 to show reports automatically on every PR. I cannot block PRs on this, (we only block on linting files or formatting metadata). But you can also see the results of the tests on every PR. If you click on &quot;Details&quot; you can see the results. We now use CircleCI instead of Travis CI (since Circle is faster).</p>
<a href="#ecma-404-update"><h3 id="ecma-404-update">ECMA-404 Update</h3></a><p>(Chip Morningstar (CM))</p>
<p>CM: ECMA-404 continues in its timeless perfection. Nothing new to report. Its mission in life is to not change.</p>
<a href="#updates-from-the-coc-committee"><h3 id="updates-from-the-coc-committee">Updates from the CoC Committee</h3></a><p>(Jory Burson (JBR))</p>
<ul>
<li><a href="https://docs.google.com/presentation/d/1FAGAtZFXUO8CPNnYKKwLXIynjqO_6v7SMQh1KxDnHPY/">slides</a></li>
</ul>
<p>JBR: (Presents slides)</p>
<p>MF: How does the GitHub block work?</p>
<p>JBR: We block on the whole tc39 org. They can see the content, but cannot comment.</p>
<p>AKI: And also on the tc39 freenode channel on IRC.</p>
<p>KM: Do we have a plan if the individual creates a new account?</p>
<p>JBR: Not in this case; the separation was somewhat mutual.</p>
<p>BT: I would also guess GitHub TOS restrict multi accounts.</p>
<p>TCN: I can confirm that from the Node perspective, GitHub is helpful to deal with multi accounts.</p>
<p>AKI: Do we need consensus on whether to name the individual? The CoC Committee focuses on privacy and confidentiality. We would like to privately share within TC39 the usernames, but not publicly. The current policy is to not disclose that information with TC39.</p>
<p>MS: What is the motivation to disclose that information?</p>
<p>JBR: The concern would be to respect the committee's right to transparency.</p>
<p>JHD: It's important to be able to know if someone who does show up on IRC, etc., that you know whether to engage with that person. It can serve as a &quot;warning&quot; that someone might need more energy.</p>
<p>AKI: It's also a concern over safety.</p>
<p>YK: Another reason you may want this to be public is because sometimes you get caught off-guard in a public forum by someone who's been blocked. It seems to reduce our legitimacy if committee members don't know anything about it and cannot respond.</p>
<p>MS: I feel it makes sense to discuss with CoC Committee, like an escalation process, if there is an issue, but I fear we are jumping the gun by exposing that information sooner.</p>
<p>YK: My concern is that these things happen fast—in real time.</p>
<p>JBR: Accountability is very important here—so you want to be able to tell someone that an individual has been blocked and then to show them.</p>
<p>AKI: Following up, do we have consensus? MS, do you have concerns?</p>
<p>MS: I guess I'm fine with it. I understand the real-time concerns of being able to verify.</p>
<p>AKI: It looks like we have consensus. This information will be published to the moderation forum.</p>
<p>KV: This is not a blanket policy?</p>
<p>AKI: Right; this leaves it up to the CoC Committee to decide when it is appropriate to disclose the information.</p>
<p>IS: We really need more mics. Maybe people should queue behind the mic.</p>
<p>(AK, AKI, MBS, BT discuss logistics)</p>
<a href="#ecma-tc53-report"><h2 id="ecma-tc53-report">Ecma TC53 Report</h2></a><p>(Peter Hoddie (PHE))</p>
<ul>
<li><a href="https://www.icloud.com/keynote/0br90r7j82NFdnqezliqGAblQ#tc53_liason_report_-_3/19">slides</a></li>
</ul>
<p>PHE: Introduction to what JavaScript for IoT is. Users for JavaScript for IoT are working on code that will be consumed through modules. Three face to face meetings a year. Just met in Austin. Next meeting is in the bay area in June. Started investigating a code of Conduct. Low barrier since Jory is part (vice president?) of the group. Sensors, communication (beyond just TCP/IP), and displays are our three areas that we would like to see realized.</p>
<p>PHE: Starting with I/O, which is a building block for everything else. Loosely borrowed an idea from Firmata that allows I/O in multiple places. We have several types of I/O we are looking at. Network socket is one of the more interesting types. It fits well with other architectures.</p>
<p>PHE: Rather than extending W3C sensors, looking at a lower level sensor driver in JavaScript. The general model of having drivers not specific to a certain sensor follows the model of previous specifications. Networking is a challenge. Can't select a specific port since there is no standardized or common shared port. Enabling users to bring their own.</p>
<p>PHE: Security: very important for user privacy and safe operation. Working on a few different approaches. (Mark?)  working on defining a secure subset of JavaScript. We want to defer to TC39 to think about the details of security. We can say that we restrict ourselves to &quot;strict mode,&quot; since IoT devices don't have 20 years of backwards compatibility. We can focus on best practices.</p>
<p>MM: The basic framework in which we pursue security is the Object Capability Subset of JavaScript. We want you to be able to choose just a secure subset of JavaScript. &quot;Don't add security; Remove insecurity.&quot;  (discusses realms proposal, Jessie.)  We want to make a standalone language specification that can be implemented; we can discuss further with TC39.</p>
<p>YK: I liked in MM's original goal for SES was that you can run any JavaScript code in it.</p>
<p>MM: Yes, SES is intended that code that follows existing best practices to continue to run.</p>
<p>YK: Yeah, so that it is a good enough goal as TC39 that I would like to spend time on. But I would not like to spend time on Jessie.</p>
<p>MM: SES and Jessie are separate. Jessie is a tiny subset of SES that runs essentially zero existing JavaScript. It is separate from SES. But Jessie code will run as SES code in an SES environment.</p>
<p>YK: Does TC53 want us to standardize anything about Jessie?</p>
<p>MM: We have not been planning in the short term to bring Jessie to TC39 committee.</p>
<p>PHE: Primarily in TC53, we are looking at the secure subset of JavaScript. Jessie is intended to extend support in TC53 down to the lowest-level devices. We however have not defined a lower bound of the devices we support. We could keep with just SES.</p>
<p>MM: Google Caja and Salesforce use SES in production and there have not been any major issues. Google EarthEngine, that has been using Caja/SES in production for years, document it by saying, just react to the occasional error message. Salesforce has a 5 million developer ecosystem running on SES, most of whose programmers just see it as JavaScript + a framework.</p>
<a href="#normative-createdynamicfunction-early-concatenates-body"><h2 id="normative-createdynamicfunction-early-concatenates-body">Normative: CreateDynamicFunction early concatenates body</h2></a><p>(Leo Balter (LBR))</p>
<ul>
<li><a href="https://docs.google.com/presentation/d/1mGBFCw4M37q4cF8JHnXzaLI2wLdOxoVEfq9RL_xMRW0/edit#slide=id.p">slides</a></li>
<li><a href="https://github.com/tc39/ecma262/pull/1479">proposal</a></li>
</ul>
<p>LBR: (Presents slides) What should we do with <code>function(&quot;--&gt;&quot;).toString();</code>?</p>
<p>MM: Since you asked what should be the result, I'm going to say &quot;throw an exception.&quot;</p>
<p>LBR: In ch, xs, it throws an error, in others there's an HTML comment. I propose we wrap the body function earlier, so that HTML comments will reflect the current behavior.</p>
<p>MM: Are you proposing that it doesn't throw an exception?</p>
<p>LBR: Yes. The proposed change is to change where this happens. It moves the Line Feed. (Presents slides).</p>
<p>MM: If the current system was what you are proposing—and if you were proposing to make it a syntax error, I would support that. I think a syntax error is a better thing for the engine to do, I think this proposal is actually a regression.</p>
<p>LBR: For clarification, yes, this thing affects an observable change. But I think any syntactical change to NXB should be discussed and it should have time for a full discussion later since it is important.</p>
<p>MM: I'm objecting to the idea that HTML comments come to be accepted where they are rejected today.</p>
<p>MF: I'd like to respond to MM's question. This is fixing an inconsistency in the spec that exists currently. The synthesised source text includes new lines in the rendering, but the function body is parsed without them. Parsing it unlike how it is displayed is an inconsistency. We should either remove the newlines in the synthesised source text or allow the HTML start comments. We shouldn't leave it as it currently is.</p>
<p>JHD : If you pass two slashes, it does work as expected. That supports the consistency argument that we should make this change.</p>
<p>YK: If there is a thing that could be rendered but not parsed, doesn't that violate the round-tripping of toString?</p>
<p>MM: The function.toString invariant has to do with output render and is in turn parsable and thus evaluable with &quot;eval&quot;. Given the structure of the spec, and since I support adding the new lines, I'd have to agree that this adheres to the principle of least surprise. Any engine that doesn't support HTML comments—as a JS engine is free to ignore them—I think this is OK, so I remove my objection.</p>
<p>YK: I remember WH having an objection to some other changes related to the HTML comment syntax. I don't remember them. But if WH doesn't object here, I'm fine. There were other cases to allow HTML comments to be supported and I wanted you to have an opportunity to discuss it.</p>
<p>WH: The issue is whether <code>--&gt;</code> is allowed at the beginning of a script. According to Annex B grammar, it's not.</p>
<p>LBR: It's not written in any grammar.</p>
<p>WH: The issue is more about if <code>--&gt;</code> is allowed at the beginning of a script or not. Adding the newlines here is a red herring. So I would not support this change. If we want to fix it, we should look at what <code>--&gt;</code> does at the beginning of various parsing contexts.</p>
<p>LBR: What is the actual behavior of the Function constructor in passing the body parameters? In this proposed change, I'd like to know that the source text has a guaranteed output.</p>
<p>WH: We don't normally dictate the spacing/parentheses placement/line breaks.</p>
<p>LBR: If we don't change this today, we end up with implementations not being consistent with the spec in a way.</p>
<p>WH: There's an inconsistency problem with <code>--&gt;</code> in other places, not just here. And that might solve the problem in the way you want.</p>
<p>LBR: I would rather not have HTML close comment at all. I'm just looking at the web reality today and what's elegant for the code.</p>
<p>WH: In Annex B, <code>--&gt;</code> is allowed only after a new line. However, implementations seem to accept that even in contexts where it's not preceded by a newline, such as in <code>eval(&quot;--&gt;&quot;)</code>. We need to figure out whether the new line prefix is necessary or not. For example, if you do <code>eval(&quot;--&gt;&quot;)</code> you don't get a syntax error even though Annex B states that you should? We should make the grammar consistent throughout the language, not just in the Function constructor.</p>
<p>MM: I'll try to clarify WH's issue. Although the current spec does imply that the acceptance of <code>--&gt;</code> is whether there is a newline or not, not just in function body but also in eval, all of the places where it should be rejected because of an absence of a newline are actually getting accepted. So the problem is that the grammar in Annex B already does not match web reality. And if you fix it there, then the newline issue there no longer affects whether <code>--&gt;</code> is accepted or not. The problem with <code>--&gt;</code> is not unique to function bodies.</p>
<p>LBR: That sounds like it would be extending the HTML comments grammar. If we cannot find consensus now, I'd rather we bring it to the end of the meeting.</p>
<p>BT: Maybe we can discuss it at the end.</p>
<p>LBR: I'd like to discuss it with browser implementers, since I'd like to fix it for this case.</p>
<p>BT: Please discuss with Leo offline.</p>
<a href="#normative-remove-implementation-defined-typeof-behavior"><h2 id="normative-remove-implementation-defined-typeof-behavior">Normative: Remove implementation-defined typeof behavior</h2></a><p>(Dan Ehrenberg (DE))</p>
<ul>
<li><a href="https://docs.google.com/presentation/d/11rVHJHCPpcwYxxLZETcjpX89WIA79IDlLhSbvUmQiO4/edit#slide=id.p">slides</a>
<a href="https://github.com/tc39/ecma262/pull/1441">PR</a></li>
</ul>
<p>DE: If you have a non-standard JS object, there's a lot of complexity on what typeof returns. In this proposal, if an object is callable, or not determines whether it returns function or object. This typeof table is simplified (points to slides).</p>
<p>MM: Clarification: how about document.all?</p>
<p>DE: That's already in the spec. That's defined.</p>
<p>MM: So document.all violates the table.</p>
<p>DE: There is spec text elsewhere that handles document.all.</p>
<p>MM: I'm not objecting to this proposal; we just need to remember that typeof has that special case.</p>
<p>JHD: There is a line in the spec that specifically covers that case.</p>
<a href="#conclusionresolution-normative-remove-implementation-defined-typeof-behavior"><h4 id="conclusionresolution-normative-remove-implementation-defined-typeof-behavior">Conclusion/Resolution</h4></a><p>(consensus)</p>
<a href="#normative-make-async-from-sync-iterator-object-inaccessible-to-ecmascript-code"><h2 id="normative-make-async-from-sync-iterator-object-inaccessible-to-ecmascript-code">Normative: Make Async-from-Sync iterator object inaccessible to ECMAScript code</h2></a><p>JHD: Presenting on behalf of André Bargull. I think this PR is not very objectionable, but it needs consensus.</p>
<p>JRL: How is this currently accessible?</p>
<p>JHD: There's a code snippet here that can produce the bug.</p>
<p>MM: There's currently a security hazard that this object might be gotten ahold of and not frozen. The SES shim has been unable to get ahold of this object, and so cannot safely freeze it. But we are not confident that it is impossible to get. If we fail to freeze it and it is gotten anyway, then we have a shared primordial mutable object, which invalidates our security assumptions.</p>
<p>JHD: You can argue that this is matching web reality as well.</p>
<a href="#conclusionresolution-normative-make-async-from-sync-iterator-object-inaccessible-to-ecmascript-code"><h4 id="conclusionresolution-normative-make-async-from-sync-iterator-object-inaccessible-to-ecmascript-code">Conclusion/Resolution</h4></a><p>(consensus)</p>
<a href="#normative-suppress-getmethod-errors-in-iteratorclose"><h2 id="normative-suppress-getmethod-errors-in-iteratorclose">Normative: Suppress GetMethod errors in IteratorClose</h2></a><p>(Kevin Smith (KS))</p>
<p><a href="https://github.com/tc39/ecma262/pull/1408">PR</a></p>
<p>KS: (Goes through code example in PR) The first iteration, we'll throw 1. Then, in the catch, does this print &quot;1&quot; or &quot;TypeError: 0 is not a function&quot;? This proposal suggests that it will rethrow that error even if the return property is not callable. It seems to be with the original spirit with IteratorClose.</p>
<p>MB: Leszek Swirski on the V8 team actually filed the bug that led to this PR. Some more context is that this change would actually enable an optimization for us, so we're in favor of the change.</p>
<p>KS: Do we have consensus on this change?</p>
<a href="#conclusionresolution-normative-suppress-getmethod-errors-in-iteratorclose"><h4 id="conclusionresolution-normative-suppress-getmethod-errors-in-iteratorclose">Conclusion/Resolution</h4></a><p>(consensus)</p>
<a href="#normative-add-export--as-ns-from-mod-to-export-production-and-module-semantic"><h2 id="normative-add-export--as-ns-from-mod-to-export-production-and-module-semantic">Normative: Add export * as ns from &quot;mod&quot; to Export production and Module Semantic</h2></a><p>(Leo Balter (LBR))</p>
<p><a href="https://github.com/tc39/ecma262/pull/1174">PR</a></p>
<p>LBR: (Shows Test262 report for PR lacking multiple implementations)</p>
<p>JHD: According to the PR, we had consensus to move forward with the feature, but we wanted to treat it more like a Stage 3 proposal. Do we want to wait until we have more unflagged implementations?</p>
<p>TST: As an implementer, I think Mozilla would be fine without blocking on additional implementations.</p>
<p>DE: Processes that TC39 could use here—some committees use multi-user buy-in. That seems like something we could use. This makes me very comfortable with merging this PR. If we only have feedback from only one browser, and feedback from tooling, I think that would not be sufficient, but here we have Mozilla's buy-in and already one implementation.</p>
<p>TST: I agree with DE.</p>
<p>SGN: ChakraCore has it too, so I think it's fine to merge it.</p>
<p>KS: We have an implementation behind a flag right now.</p>
<a href="#conclusionresolution-normative-add-export--as-ns-from-mod-to-export-production-and-module-semantic"><h4 id="conclusionresolution-normative-add-export--as-ns-from-mod-to-export-production-and-module-semantic">Conclusion/Resolution</h4></a><p>(consensus)</p>
<a href="#normative-require-at-least-four-digits-in-string-representations-of-negative-years"><h2 id="normative-require-at-least-four-digits-in-string-representations-of-negative-years">Normative: Require at least four digits in string representations of negative years</h2></a><p>(Richard Gibson (RGN))</p>
<p><a href="https://github.com/tc39/ecma262/pull/1407">PR</a></p>
<p>RGN: (discusses the PR)</p>
<p>WH: How does this deal with year zero, and what happens when the year is +/- Infinity? You have a check in the algorithm to exclude NaNs but not infinities.</p>
<p>RGN: That is not affected by this PR. The year before year 1 is year 0, and the year before that is year -1. Year 0 is year 1 BCE; year -1 is year 2 BCE, etc.</p>
<p>RGN: Infinities are rejected earlier in the construction of dates.</p>
<a href="#conclusionresolution-normative-require-at-least-four-digits-in-string-representations-of-negative-years"><h4 id="conclusionresolution-normative-require-at-least-four-digits-in-string-representations-of-negative-years">Conclusion/Resolution</h4></a><p>(consensus)</p>
<a href="#stringprototypematchall-for-stage-4"><h2 id="stringprototypematchall-for-stage-4">String.prototype.matchAll for Stage 4</h2></a><p>(Jordan Harband (JHD))</p>
<p><a href="https://github.com/tc39/ecma262/pull/1480">Spec PR</a></p>
<p>JHD: There are multiple implementations. I would like to make this Stage 4.</p>
<a href="#conclusionresolution-stringprototypematchall-for-stage-4"><h4 id="conclusionresolution-stringprototypematchall-for-stage-4">Conclusion/Resolution</h4></a><p>(consensus)</p>
<a href="#datestyletimestyle-for-stage-3"><h2 id="datestyletimestyle-for-stage-3">dateStyle/timeStyle for Stage 3</h2></a><p>(Daniel Ehrenberg (DE))</p>
<ul>
<li><a href="https://docs.google.com/presentation/d/17Xsw43vHocojTXisuTfpIv37JHKqwWtvrXcL-7VrJQ8/edit#slide=id.p">slides</a></li>
<li><a href="https://github.com/tc39/proposal-intl-datetime-style">proposal</a></li>
</ul>
<p>DE: (presents slides)</p>
<p>WH: What is the difference between short and medium format in the example?</p>
<p>DE: There is a difference, but this example may be wrong. You should consult CLDR if you're more interested. For stage 3, Leo has signed off as has Frank. Is this ready for Stage 3?</p>
<p>MS: So these patterns are not standardized?</p>
<p>DE: They are specified in CLDR. This is like most of the rest of ECMA-402. We cannot nail it down completely.</p>
<p>MS: So what you're really saying is that we are deferring to another standard.</p>
<p>DE: We really <em>want</em> to give implementations the ability to do these tailorings while remaining spec-compliant.</p>
<p>MS: Seems like a developer wants standardized behavior across all implementations.</p>
<p>DE: It's just not possible for anything in ECMA-402 to work like that.</p>
<p>WH: If it is implementation-defined, how do you write tests for it?</p>
<p>DE: Would the Bocoup people want to answer this?</p>
<p>LBR: We cannot have observable tests for it, but it is pointing to a specific standard.</p>
<p>DE: We've compromised by allowing people to turn off these tests and comparing the strings, which is actually still pretty useful.</p>
<p>MM: What is the metadata?</p>
<p>DE: A list of locales, possibly among other things. It was a difficult discussion to get the right balance, but I'm happy with the work Rick and Leo have done to strike that balance.</p>
<a href="#conclusionresolution-datestyletimestyle-for-stage-3"><h4 id="conclusionresolution-datestyletimestyle-for-stage-3">Conclusion/Resolution</h4></a><p>Proceeding to Stage 3</p>
<a href="#intldatetimeformatprototypeformatrange-for-stage-3"><h2 id="intldatetimeformatprototypeformatrange-for-stage-3">Intl.DateTimeFormat.prototype.formatRange for Stage 3</h2></a><p>(Felipe Balbontín (FBN))</p>
<ul>
<li><a href="https://docs.google.com/presentation/d/e/2PACX-1vRiHjIBX74841Hf2vyeqMm9jbb-pzQoFwh4Ecdvz8JISAGXuV_jGv_3Id_jOXxP3SWjF9z9lcyL9NPX/pub">slides</a></li>
<li><a href="https://github.com/tc39/proposal-intl-DateTimeFormat-formatRange">proposal</a></li>
</ul>
<p>FBN: (presents slides)</p>
<p>SFC: I'm very happy with the shape of this proposal, it's going to solve a major pain-point in date formatting. I support it moving to Stage 3.</p>
<p>MM: There are serious security concerns with using implicit calls Date.now(). Are there any remaining implicit calls to Date.now() left?</p>
<p>FBN: Currently the regular DateTimeFormat.prototype.format calls Date.now().</p>
<p>MM: It's a disaster to call into Date.now() directly in DateTimeFormat (the intrinsic now); it should call the prototype method.</p>
<p>DE: You're aware that this is how Date.format works now?</p>
<p>MM: I was not aware, no. If that's the case right now, then we have a real problem.</p>
<p>DE: How does this relate to web specifications that may do this?</p>
<p>MM: Web specs are considered to be host objects and treated as unsafe. Here we're talking about ECMAScript built-ins. We've been trying to keep hidden state/IO out of the ECMAScript language. The fact that i18n has proceeded with it, this has me rather terrified.</p>
<p>CPO: There are two places where we use the intrinsic now. They are both places where we transform them into a string before we return the string to the user.</p>
<p>MM: Can you infer the milliseconds or seconds?</p>
<p>CPO: Seconds yes, milliseconds no.</p>
<p>MM: The other place I've been concerned about in theory is obtaining the current timezone. But it's much harder to create a covert channel with time zones, which are expected to change much less frequently. I do not consider this a practical hazard.</p>
<p>CPO: That has been the behavior for a very long time, by the way.</p>
<p>AK: The difference with the host objects being more powerful is throughout the language.</p>
<p>MM: The Realms API is best understood as a way for JavaScript code to define a host for other JavaScript code. Anything that is to be provided to JavaScript by a host should be providable, or not, through the Realms API. But the initial contents of the realm should be everything JavaScript defines as a standard, host-independent part of the language.</p>
<p>AK: I think I understand... it sounds like you're saying the Intl group is not taking SES considerations. But that's not unique to Intl. But Intl probably won't be on embedded devices.</p>
<p>MM: True... maybe we could say that an implementation omitting Intl can still be a valid EcmaScript implementation.
(Clarification: In a side discussion afterwards, we verified that a platform, like XS, that omits all of ECMA-402 can still be a conformant implementation of ECMA-262, and therefore of standard EcmaScript.)</p>
<p>DE: This is a side issue that does not block the current proposal. We decided this was best to leave these kinds of decisions up to the library user. I think it's really best if we can find multiple solutions here.</p>
<p>SFC: Can anyone with these concerns engage me, Leo, and the editors to discuss them offline?</p>
<p>YK: I think I would appreciate a simple definition of primordials.</p>
<p>MM: Primordials are those objects, other than the global object, that are required by ECMA-262 to exist before code starts running.</p>
<a href="#conclusionresolution-intldatetimeformatprototypeformatrange-for-stage-3"><h4 id="conclusionresolution-intldatetimeformatprototypeformatrange-for-stage-3">Conclusion/Resolution</h4></a><ul>
<li>Stage 3 acceptance</li>
</ul>
<a href="#uniform-parsing-of-quasi-standard-dateparse-input-for-stage-2"><h2 id="uniform-parsing-of-quasi-standard-dateparse-input-for-stage-2">Uniform parsing of quasi-standard Date.parse input for Stage 2</h2></a><p>(Richard Gibson (RGN))</p>
<ul>
<li><a href="https://github.com/tc39/proposal-uniform-interchange-date-parsing">proposal</a></li>
<li><a href="https://docs.google.com/presentation/d/1LuJzeR7Y-e-LcQObQesJfJsIVGkiZCMoZhVMO5OxIoc/edit">slides</a></li>
</ul>
<p>RGN: (presents slides)</p>
<p>WH: In the spec's draft spec text, when there is a nonempty set of dates in the toString and toUTCString scenarios, you always choose the lowest-value member of the set. Whether that's a good idea depends on whether toString and toUTCString round or truncate.</p>
<p>RGN: That is a formalization of the behavior that's already specified. It leaves unspecified what happens with milliseconds—and in fact, it's truncated off; they will always serialize the same in any of these three methods (toString, toUTCString) because of the truncation.</p>
<p>WH: Ok, that's good. I was worried about the case where these methods would round the milliseconds, in which case the spec might inadvertently require you to parse something like &quot;...T13:00:00&quot; as ...T12:59:59.5 because that's the lowest value that would round to 1PM.</p>
<p>SFC: In the slides, you have tables including different specifications. I've seen code that works in Firefox but not in Chrome, so I'm glad that these things are being specified. It's not entirely clear to me, however, if this errors more on the side of leniency or strictness with parsing.</p>
<p>RGN: I'd like to carve out an area in our interchange format. Anything that doesn't parse clean has to be rejected. If you have something that looks like the RFC or the EcmaScript interchange format, it must pass all the checks to be parsed as not a number.</p>
<p>RGN: You have cases where input is obviously invalid, except with weird edge cases (like the February 30th example). All the cases that I'm changing are rejected by at least one engine already.</p>
<p>BT: This feature seems to be all about driving interoperability.</p>
<p>RGN: One thing that I can commit to is that if there's anything that's required to support interoperability, then we should include that. I do still want to move the ball forward.</p>
<p>AKI: What about February 30, 1712?</p>
<p>RGN: In the version of the Gregorian calendar ECMAScript is based on, there was not a February 30th in 1712.</p>
<p>SFC: If we did want to move in the direction of supporting other calendars for date parsing, that could be something for the Intl object.</p>
<p>RGN: Or Temporal.</p>
<p>AK: If I were to restate what BT said, we may have to change what's in the proposal as we go, but it would be nice to know as an implementer how much time we'll be playing whack-a-mole with those changes.</p>
<p>RGN: My intention is to make a full picture of what the landscape looks like.</p>
<p>BT: It's hard to say we want this in a standard without understanding that. It's what this feature is about.</p>
<p>AK: I would second that. To give an example, someone could say, &quot;let's make JavaScript more interoperable,&quot; and we all agree on that, and finish that at Stage 2.</p>
<p>RGN: We can commit to a desire that may never materialize.</p>
<p>AK: We'd want the desire to be more concrete before committing to Stage 2.</p>
<p>DE: As someone who made a little change to Date.parse in V8, I really think that we should define this fully. We've talked about this before. I think it may take a lot of work to define it, but I think it would be worth it. I don't think it's that valuable to define a couple more cases and incrementally do this over time.</p>
<p>RGN: Do we want portability of something like &quot;2019-03-26Q&quot;? Do you want to accept something that's not part of any specification at all? But that was supported because of historical browser engine support only?</p>
<p>DE: We do want portability. This may be something of a union and something of an intersection.</p>
<p>RGN: I'm interested in a post-check on that. I'm interested in the formats that the rest of the internet has committed to in terms of portability. But if we do want more like, we want to accept something that all engines have accepted, ...</p>
<p>DE: I don't think it should be necessarily the union. But we need to do damage control because there is not currently interoperability on Date.parse. We need to focus on interoperability. On Temporal, I really want to define for Temporal how it can accept the ISO-8601 strings. That's unrelated to the goal for Date. So I'm wondering what the rest of the committee thinks about these goals.</p>
<p>LBN: I would like to request for Stage 2, even if this proposal doesn't advance. I would like more input from others, and I don't think this meeting is a fair enough time for this work.</p>
<p>KM: My main concern is that there's enough random pages with compatibility issues that break whenever you make changes to Date.parse(). I think it's a bottomless pit.</p>
<p>DE: I agree, this is the experience I have had in V8. I want to hold off on making any changes for what the standard will be.</p>
<p>KM: Even trying to increase the surface area of things we accept has broken stuff.</p>
<p>RGN: I want to be more restrictive.</p>
<p>KM: It's really hard to tell.</p>
<p>DE: Interoperability spec work is hard. That's why we're here as professional spec writers figuring this out. It would be unfair to implementers to expect them to piece out this work and expect them to determine independently how to proceed as opposed to proceeding together once the interoperability path has been decided.</p>
<p>LBR: The effects are clearly way more spread than the actual spec text. I feel like there's a lot of uncertainty that we will affect what we're restricting or allowing. As of this minute, I can't consume all of that information. I would like others to investigate what else is being changed here.</p>
<p>MB: To respond to DE's comments, I'm worried we may never get a full spec to solve all Date.parse()'s problems if we try to do it all in a single proposal. I think we should be open to accept smaller, incremental improvements.</p>
<p>DE: The author of the previous proposal (Morgan) stopped working on the project because they left Mozilla.</p>
<p>RGN: As far as I know, the previous proposals never even got this far.</p>
<p>TST: To clarify, the previous proposal that Morgan was working on has nothing to do with TC39. They just left and we just didn't have the resources to continue working on it.</p>
<p>SFC: My frame of mind is more similar to what Mathias said.</p>
<p>MB: A person stops working on a proposal and then nothing happened anymore. If we focus more on smaller improvements, we might reduce the bus factor, and get more people willing to help champion/author the smaller proposals.</p>
<p>RGN: If we want a full spec, then how much of the intersection (shows chart) do we pull in? I don't know what it looks like to make incremental changes here.</p>
<p>DE: I really think that solving this WebCompat issue is a really important goal. If we're talking about interchange outside ECMAScript, I'd focus on Temporal.</p>
<p>RGN: Temporal is indeed a different proposal, but Date.parse() is already on the internet.</p>
<p>BT: Do we have consensus on Stage 2?</p>
<p>DE: I think we should really see more interoperability research first.</p>
<p>BT: Personally, I wouldn't be the lone dissenter, but I would like to see more details on the effect of this change.</p>
<p>LBN: Does anyone volunteer time to support RGN on this?</p>
<p>DE: It's hard to figure out how to help unless we have a shared understanding of goals.</p>
<p>RGN: The goals of the proposal that I'm bringing forward are to get uniform parsing of every serialization.</p>
<a href="#conclusionresolution-uniform-parsing-of-quasi-standard-dateparse-input-for-stage-2"><h4 id="conclusionresolution-uniform-parsing-of-quasi-standard-dateparse-input-for-stage-2">Conclusion/Resolution</h4></a><ul>
<li>We are at timebox. Proposal not currently approved. Maybe discussion can continue on Thursday.</li>
</ul>
<a href="#promiseallsettled-for-stage-3"><h2 id="promiseallsettled-for-stage-3">Promise.allSettled for Stage 3</h2></a><p>(Mathias Bynens (MB))</p>
<ul>
<li><a href="https://github.com/tc39/proposal-promise-allSettled">proposal</a></li>
<li><a href="https://docs.google.com/presentation/d/1A5kGO-YF0imcltyQYZIsCDGHG_k-9IZ6CPMfWlFl85s/edit">slides</a></li>
</ul>
<p>MB: (presents slides)</p>
<p>MB: The main questions are why do we add Promise.allSettled instead of Promise.reflect? My answer is that it's different enough that it should be a separate proposal. I'd like to propose that we close this issue on <code>Promise.reflect</code> and move on with that consensus.</p>
<p>SGN: What is Promise.reflect?</p>
<p>MB: It's basically something like the userland function that you'd write today to get similar behavior. It keeps track of the promise state, and it takes it turned into an object with a status/value pair. Promise.allSettled does not block adding that feature in the future.</p>
<p>YK: What was Bluebird's rationale for <em>deprecating</em> allSettled?</p>
<p>MB: I don't know exactly why they went that way. The userland precedent for allSettled is there.</p>
<p>YK: I can imagine they deprecated the thing that maybe it was misused instead of this other thing.</p>
<p>MB: <code>Promise.reflect</code> is a lower-level primitive than allSettled. The details are in the repo. We believe these are separate questions and we can add reflect in the future.</p>
<p>MM: The <code>Promise.reflect(promise)</code> code you show is not safe of re-entry hazards, because it calls <code>promise.then(...)</code> directly on the alleged promise argument, rather than <code>Promise.resolve(promise).then(...)</code>. You're not proposing &quot;reflect&quot;, which is fine. But <code>Promise.all()</code> is careful only to do <code>Promise.resolve(x).then(...)</code> on each incoming alleged promise, rather than doing .then directly. Does <code>Promise.allSettled()</code> do so as well?</p>
<p>MB: (shows the spec) I'm sure at the top of my head where in the spec this happens.</p>
<p>MM: Given that we're agreed that this is what it <em>should</em> do, I'm happy for today.</p>
<p>MB: (continues his presentation)</p>
<p>YK: I like allSettled even if reflect is more primitive. It seems common and non-obvious to implement correctly.</p>
<p>MF: What was the process for choosing those status strings? Have you received feedback on them?</p>
<p>MB: Explicitly discussed that they were string values. We managed to resolve that issue offline. Part of what I'd like to do here is reaffirm consensus.</p>
<p>MF: I'd like to respond to the comment about the status being a &quot;safe way&quot; to go forward. I'm not sure if I totally agree with that; going with either one could be safe. I don't recall the conversation on strings vs. booleans; I just don't think that should be the justification.</p>
<p>MB: What we're showing also matches every userland implementation out there today.</p>
<a href="#conclusionresolution-promiseallsettled-for-stage-3"><h4 id="conclusionresolution-promiseallsettled-for-stage-3">Conclusion/Resolution</h4></a><ul>
<li>Stage 3 acceptance</li>
</ul>
<a href="#stringprototypereplaceall-for-stage-2"><h2 id="stringprototypereplaceall-for-stage-2">String.prototype.replaceAll for Stage 2</h2></a><p>(Mathias Bynens (MB))</p>
<ul>
<li><a href="https://github.com/tc39/proposal-string-replace-all">proposal</a></li>
</ul>
<p>MB: November 2017 was the last time we visited this proposal. We decided that if you want to solve this, replaceAll should be the name, and we should match the semantics of replace, like get-substitution. I can see now that this is probably the right thing to do. We have spec text now. I believe we fulfilled all the requirements to go to stage 2.</p>
<p>JHD: Was there any further exploration of a RegExp escaping template tag?</p>
<p>MB: This is a super-common thing to do who want functionality like this. Where they just want to replace all instances in a string with another string.</p>
<p>JRL: When you pass in a non-global regex as the search string, what happens?</p>
<p>MB: That's an open issue (which you filed!). The current spec text gives us a way forward. We can address that detail before Stage 3.</p>
<p>YK: ...</p>
<p>MS: What semantic do you prefer for a RegExp searchValue?</p>
<p>MB: If I had it my way, replaceAll wouldn't support RegExp at all, it would only support the new use case of global string replacement, and not do GetSubstitution etc. But I can see how this is more internally consistent within the language. We should probably match <code>matchAll</code> w.r.t. non-global RegExps.</p>
<p>JHD: At various times it threw or added a 'g' flag. But now it just returns a single match.</p>
<a href="#conclusionresolution-stringprototypereplaceall-for-stage-2"><h4 id="conclusionresolution-stringprototypereplaceall-for-stage-2">Conclusion/Resolution</h4></a><ul>
<li>Stage 2 acceptance</li>
<li>Stage 3 reviewers: MS, RGN, and DE</li>
</ul>
<a href="#private-declarations-for-stage-1"><h2 id="private-declarations-for-stage-1">Private declarations for Stage 1</h2></a><p>(Justin Ridgewell (JRL))</p>
<ul>
<li><a href="https://github.com/tc39/proposal-private-declarations">proposal</a></li>
<li><a href="https://docs.google.com/presentation/d/1tA50t5sCiXVokMCfJAZiP9aYWaRjsj_SftsdHkzLmk8">slides</a></li>
</ul>
<p>JRL: (presents slides)</p>
<p>MM: I like this direction. I want to make sure we are preserving the integrity constraint on private state that distinguishes initialization, which registers in the weak map. Whether it's outer or private, on the &quot;#x = 0&quot;, I just want to make sure that's the registration of the instance of Ex, and if in the constructor you'd have &quot;this.#x = 0;&quot; but #x wasn't previously declared...</p>
<p>JRL: I haven't changed those semantics; that case should still throw. You have to declare a private field on the class so it can be initialized on instances, you can't just access an outer private on an instance that didn't declare the field.</p>
<p>MM: What about for non-classes? One of the things about this whole approach that makes it appealing is that it generalizes to object literals as well.</p>
<p>JRL: That was a nebulous topic when Bradley presented on this last time. We could add object-private state later on.</p>
<p>MM: I'm very happy with this, I'm glad that you're also opposed to abusing the computed property syntax.</p>
<p>CM: I like the general flavor of what you're trying to do. I might come very close to bikeshedding on syntax, but now we're overloading &quot;private&quot; to mean non-private, private on the file scope. I've gotten used to <code>#</code> meaning &quot;private&quot;, and now we have <code>private #</code> to mean &quot;not really private&quot;.</p>
<p>YK: I don't necessarily agree that this scoping is that difficult to understand. We should be careful with complicating the model.</p>
<p>KCL: Alternative 1 has a problem—if you were to bundle this with unminified code. There would be nothing stopping me from leaking scope.</p>
<p>JRL: It would require your concatenations tool to respect module scope. Alternative 2 would require us to change our class syntax, and would still require the concatenations to respect scope.</p>
<p>KCL: Could that not be a syntax error though, that would not be web-compat?</p>
<p>JRL: Unfortunately not.</p>
<p>DE: Can we make overflow time for this? I would like to have this discussion before promoting this to Stage 1.</p>
<p>YK: In general, we need to get more clear on whether to lean on module scoping. A lot of people come from other programming languages where scoping doesn't work like this. I used to really like the idea of making scoping intuitions without using the lexical keyword. (Describes slide example) would be improved if you don't reuse mutation syntax. I have come to look at that code and find it more confusing than when I used to.</p>
<p>WH: I share the syntax confusion worries mentioned already. The other thing I'm unclear about is, what is <code>x.#y</code> supposed to mean? Does it call get/set/init? If you have Object-dot-hash-y?</p>
<p>JRL: I am not introducing any changes with respect to the semantics of access.</p>
<p>WH: So it doesn't cause get/set/init to be called?</p>
<p>JRL: Correct. This PrivateName class is just userland code I can write today. I'm not proposing that we actually reify private state yet.</p>
<p>JHD: Referencing the alternate proposals: Classes have to effectively install every private field in scope on every new instance that's created?</p>
<p>JRL: Only if you declare it on that class. Undeclared private fields wouldn't be installed.</p>
<p>JHD: Similarly then, can you show me an example of using it in an object literal? Is your intention that it would work there?</p>
<p>JRL: Not my current plan. That could be a future proposal that reuses the private declarations to do object private state.</p>
<a href="#conclusionresolution-private-declarations-for-stage-1"><h4 id="conclusionresolution-private-declarations-for-stage-1">Conclusion/Resolution</h4></a><ul>
<li>Will continue discussion in overflow time. Proposal not yet approved for Stage 1.</li>
</ul>

</body>
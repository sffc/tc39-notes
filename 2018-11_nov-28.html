<!doctype html>
<meta charset="utf-8">
<link rel="apple-touch-icon" sizes="180x180" href="img/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="img/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="img/favicon-16x16.png">
<link rel="manifest" href="img/site.webmanifest">
<link rel="mask-icon" href="img/safari-pinned-tab.svg" color="#5bbad5">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/2.6.0/github-markdown.css" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github-gist.min.css" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/javascript.min.js"></script>
<title>November 28, 2018 Meeting Notes</title>
<body class="markdown-body">
<a href="javascript:history.back()">Back</a>
<a href="#november-28-2018-meeting-notes"><h1 id="november-28-2018-meeting-notes">November 28, 2018 Meeting Notes</h1></a><hr>
<p>Waldemar Horwat (WH), Mark Miller (MM), Till Schneidereit (TST), Michael Ficarra (MF), Michael Saboff (MS), Shu-yu Guo (SYG), Rex Jaeschke (RJE), Yehuda Katz (YK), Chip Morningstar (CM), Mariko Kosaka (MKA), Jordan Harband (JHD), Dave Herman (DH), Pieter Ouwerkerk (PO), Aki Rose (ARE), Kevin Smith (KS), Peter Hoddie (PHE), Godfrey Chan (GCN), Adam Klein (AK), Mathias Bynens (MB), Keith Miller (KM), Mattijs Hoitink (MHK), Justin Ridgewell (JRL), Randy Luecke (RLE), Daniel Ehrenberg (DE), Sathya Gunasekaran (SGN), Kevin Gibbons (KG), Alan Schmitt (AS), Ross Kirsling (RKG), Shane Carr (SCR), Nathan Hammond (NHD), Ilias Tsangaris (IT), Brian Terlson (BT), Augustus Yuan (AYN), Frank Yung-Fong Tang (FTG), Felipe Balbontin (FAB), Thomas Levy (TL), Yulia Startsev (YSV), Natalie Silvanovich (NSH), J.F. Paradis (JFP), Sebastian Markbage (SM), Taaeu Zagallo (TZO), Eric Faust (EFT), Dustin Savery (DSY), Patrick Soquet (PST), Sebastian McKenzie (SMK), Tab Atkins (TAB), Lin Clark (LCK), Reefath Rajali (RRI), Devin Rousso (DRO), Shaheer Shabbir (SSR), Mrelita Tiwari (MTI), Jonathan Dallas (JDS), Brendan Eich (BE)</p>
<p>Remote:
Ron Buckton (RBN), Bradley Farias (BFS), Robert Pamely (RPY), Leo Balter (LBR), Istvan Sebestyen (IS), Richard Gibson (RG), Guy Bedford (GB), CWS Watts (CWS)</p>
<hr>
<a href="#agenda"><h2 id="agenda">Agenda</h2></a><ul>
<li><a href="https://github.com/tc39/agendas/blob/master/2018/11.md">Agenda</a></li>
</ul>
<a href="#memory-model-bug-drf-sc-bug"><h2 id="memory-model-bug-drf-sc-bug">Memory Model bug DRF-SC bug</h2></a><p>(Shu-yu Guo)</p>
<ul>
<li><a href="https://github.com/tc39/ecma262/issues/1354">issue</a></li>
</ul>
<p>SYG: Want to recap that there is a memory model bug. The good news is the spec is wrong. Evaluation results in candidate executions: set of events. CAndidate executions are constrained by the memory model. If your program doesn't have any data races, it should be sequentially be consistent. Data race free programs are sequentially consistent (DRF-SC). The relations in the memory model are listed
Agent order
Synchronizes with
Happens before
Memory order
Reads from</p>
<p>SYG: Original bug was found in Web Assembly. Wasm is using MM for interop. CWS who is the author found is on the call. The wasm paper has fixed it in a similar way so he will talk.</p>
<p>SYG: DRF-SC counter example</p>
<pre><code><span class="hljs-selector-tag">Agent</span> 1
<span class="hljs-selector-attr">[W1]</span> <span class="hljs-selector-tag">Atomics</span><span class="hljs-selector-class">.store</span>(<span class="hljs-selector-tag">x</span>, 0, 1);
<span class="hljs-selector-attr">[Wy]</span> <span class="hljs-selector-tag">Atomics</span><span class="hljs-selector-class">.store</span>(<span class="hljs-selector-tag">y</span>, 0, 1);

<span class="hljs-selector-tag">Agent</span> 2
<span class="hljs-selector-attr">[W2]</span> <span class="hljs-selector-tag">Atomics</span><span class="hljs-selector-class">.store</span>...
</code></pre>
<p>(See slide)</p>
<p>2,1 is allowed Program DRF but not SC.</p>
<p>SYG: There is no way to interleave the statements to produce 2 and 1. In this example it is clear we should print 2,2 or 1,1. This is loading an atomic store that is fenced by the atomic loading. Does anyone have differing intution?</p>
<p>SYG: Now to fix this, conrad has suggested the minimalistic fix which I want to point a counter example variant. If I were to replace atomics store with atomics.load, should 2,1 be allowed?</p>
<p>SYG: There might no interleaving that explains an output. We still make decisions about what can happen even if there are data races.</p>
<p>DE: Any compiler optimizations?</p>
<p>SYG: Not that we know of?</p>
<p>CWS: Compilers aren't going to do something like this. The wasm fix, allows 2,1 to be printed here. The wasm fix isn't as far as I know allowing compiler optimizations but.</p>
<p>JF: Better way to think about this example, why do you want users to write this code? You're writing to x and you have published the value. Agent 2 is saying y is looping through to see y. I don't think 2,1 should be allowed.</p>
<p>CM: How is there a data race here?</p>
<p>SYG: W1 and W2 are in a data race.</p>
<p>CWS: The strong fix there could be compiler optimizations but the weak fix does not.</p>
<p>SYG: I am convinced that ..</p>
<p>SYG: Not sure if there are any compiler optimizations that would produce 2,1 in the racy example (Counter Example 1 Variant).</p>
<p>WH: Common subexpression elimination would do it.</p>
<p>SYG: Just one of them?</p>
<p>WH: Here is one. A simple compiler optimization that might happen is a compiler might do common subexpression elimination on just R1:</p>
<p>Agent 2:</p>
<pre><code>[<span class="hljs-meta">W2</span>] x[<span class="hljs-number">0</span>] = <span class="hljs-number">2</span>;
[<span class="hljs-meta">Ry</span>] <span class="hljs-keyword">if</span> (Atomics.load(y, <span class="hljs-number">0</span>) == <span class="hljs-number">1</span>) {
[<span class="hljs-meta">R1</span>]   print(x[<span class="hljs-number">0</span>]);  <span class="hljs-comment">// Compiler can replace this with just print(2);</span>
[<span class="hljs-meta">R2</span>]   print(x[z]);  <span class="hljs-comment">// z happens to be zero at runtime but compiler doesn't know that</span>
    }
</code></pre>
<p>WH: Thus it would be problematic to disallow 2,1 in the racy example. We should allow it.</p>
<p>SYG: To be fair disallowing this would disallow optimizations.</p>
<p>CM: If it introduces incorrectness is that an optimization?</p>
<p>SYG: Currently in the memory model we allow this and we need to debate if this is actually allowed.</p>
<p>WH: If you cannot do common subexpression elimination, there is something wrong in the memory model.</p>
<p>DE: About intuition, the wasm memory model allows it. Unless we have a good reason for the memory models should coincide.</p>
<p>SYG: That's why conrad is on the call. I am pretty convinced that we should allow this despite the counter example.</p>
<p>DE: We should be as restrictive as possible before we allow.</p>
<p>SYG: So the other con to disallowing this is the.. The fix to disallowing this would change the atomics of these examples.</p>
<p>CWS: The strong fix is stronger than that -- it introduces a not complete a notion of total ordering. It does change the semantics... abstracting the str</p>
<p>SYG: I also don't know the strength of changing non-atomics changes for compiler writers. There is a lot of cons</p>
<p>CM: If these optimizations... if X was not shared, there would be no interference.</p>
<p>?? R1S4:\  If you're trying to have a low latency thing...</p>
<p>DE: If you want to communicate between Javascript and web assembly threads I think it's important we can optimize them.</p>
<p>DH: Couple quick points, first want to second Dan's point that diverging from sugar array buffer seems... if we find a difference between the two we should engage. If we have disagreements we shouldn't accept it blindly. There should be a high bar for forking behavior. Chip was mentioning a predictable behavior but it's not very practical in memory models. We are in a state where there is no straightforward semantics. There will be surprising behaviors unless you want you lose optimizations. We can't just go off the example and say that looks wrong -- we want the optimizations. I don't think looking at just these examples is sufficient.</p>
<p>CWS: My intuition is to allow the minimalistic fix... you are opening up to having weird architecture for optimizations.</p>
<p>CM: I think I have to fallback on &quot;threads are evil&quot;.</p>
<p>SYG: If you do not use data races, you have more predictability and we are trying to preserve that guarantee.</p>
<p>CM: Bringing the naive programmer intuition.. If you're going to do subtle cross thread comms, you need a specialist. Normal people should never touch it. We should be explicit.</p>
<p>WH: Intuition here isn't that Ry is doing something strange. Instead, the combination of R1 and R2 is doing something funny. The mental model that is appropriate here is that racing x[0] = 1 and x[0] = 2 in different threads results in x[0] being in a quantum superposition of the values 1 and 2. Reading x[0] multiple times can sometimes return 1 and sometimes return 2.</p>
<p>DH: Because SAB is a data structure.. You can abstract around it. A javascript programmer can understand that. X[0] is never gonna be a scary thing as long as it's not operating on a shared array buffer (SAB)</p>
<p>TL: Wanted to point well don't we use atomics for these full memory fences, other languages allow you to release the fence. Shouldn't we have that option?</p>
<p>SYG: In JavaScript there is no weaker ordering that... there is no sequentially consistent fences. A sequentially consistent fences are too slow in that if people depend on it, we can't back out of it. As the need arises we have room to grow the model but currently it's here or nothing.</p>
<p>SYG: I understand this an esoteric topic but I hope it was clear that we should allow 2,1 in the original example and disallow 2,1 in the counter example.</p>
<p>SYG: Counter example 2... on agent 1 we do an exchange (Atomics.xchg). We non atomically store 1 and then we atomically exchange it for 2. In this scenario 1 2 is allowed and program DRF but not SC. The weakest fix given by conrad would disallow this.</p>
<p>CWS: The thing about this is that these two examples are disallowed by 2 separate rules.</p>
<p>WH: I was looking at the fix. I saw the two new rules that were duals of each other. One of these addressed the original counterexample. I had been wondering what a real counterexample was that motivated the other new rule. Thank you for showing it!</p>
<p>SYG: The paper is not published but recommend people to read it once it is. CWS are you allowed to share the draft? With permission, I'll post to reflector.</p>
<p>CWS: No. Especially if you are a reviewer of PLDI.</p>
<p>SYG: People who want to email me, can read it unless you are a reviewer.</p>
<p>WH: In addition to the strong and weak solutions, there was an intermediate solution on GitHub, correct? What are CWS's thoughts about it?</p>
<p>CWS: Thoughts on intermediate... I strongly disapprove of the strong fix because of the problems it causes. Intermediate fix is unclear; its one advantage is that it the makes the memory model smaller, but that's not necessarily something we should be optimizing. I want to give a little proof that the intermediate the solution doesn't have issues.</p>
<p>WH: Are we convinced the weak solution will fix the problems?</p>
<p>CWS: Yes. There is a proof in the paper.</p>
<p>SYG: We don't understand the full ramifications of the intermediate solution.</p>
<p>WH: [Responding to CWS] Good. Then I agree we should go with the weak solution.</p>
<p>NHD: In addressing this we have 2 concerns: we have the compiler side in that it is optimized and performant. The other is making it so that mere mortals can accomplish writing safe code. Our current API doesn't enable that, which maybe means there needs to be a future consideration for Atomics.</p>
<p>SYG: I thought we agreed... mere mortals stops at data race free programs. If the bar we want to understand that programs with data races should be more intuitive that is a very different and hard problem.</p>
<p>NHD: We could guarantee total ordering using fences... that doesn't require it at the memory model layer, but could instead be accomplished at an API level.</p>
<p>SYG: That seems totally fine -- adding APIs to atomics that give you stronger guarantees.</p>
<a href="#conclusionresolution-memory-model-bug-drf-sc-bug"><h4 id="conclusionresolution-memory-model-bug-drf-sc-bug">Conclusion/Resolution</h4></a><ul>
<li>Weak fix</li>
</ul>
<a href="#hash-bang-grammar"><h2 id="hash-bang-grammar">Hash Bang grammar</h2></a><p>(Bradley Farias)</p>
<p>BFS: We altered the text lightly instead of having it being phrased. We moved it to be part the tokenization and lexical grammar. Basically at the start of module or script is that Hashbang Comment and other types of comments are discarded from the stream of the outputs. No tests but seeking Stage 3 for this. Any comments or concerns?</p>
<p>KG: Who were the reviewers?</p>
<p>BFS: I didn't actually... get reviewers... long time ago we talked about this and we wanted to push to stage3 ... Only people who looked at it was the last time at the meeting. WH gave a review and thumbs up?</p>
<p>WH: Unless you changed the proposal since I gave you the thumbs-up, you can count it as a positive formal review from me.</p>
<p>AK: Generally I would encourage champions to check off the process document boxes before coming to the committee asking for stage advancement.</p>
<p>BT: We can get it reviewed in 30 minutes?</p>
<p>RJE: Can we defer to later today?</p>
<p>KG: I can review by tomorrow morning.
BFS: Sounds good.</p>
<a href="#conclusionresolution-hash-bang-grammar"><h4 id="conclusionresolution-hash-bang-grammar">Conclusion/Resolution</h4></a><ul>
<li>Deferred for review by KG and rediscuss tomorrow morning</li>
<li>Follow up after lunch: No objections.</li>
<li>Stage 3 acceptance</li>
</ul>
<a href="#decorators-stage-2-update"><h2 id="decorators-stage-2-update">Decorators Stage 2 update</h2></a><p>(Daniel Ehrenberg)</p>
<ul>
<li><a href="https://docs.google.com/presentation/d/12QtzhGvtA4bf7tznPzIeYH5aLEo40Kwfs3vpJxaSbHE/edit#slide=id.p">slides</a></li>
</ul>
<p>DE: We realized decorators were still missing something and why it's important for v1... wanted to hear concerns for stage 3.</p>
<p>DE: New feature: Some people were mentioning a debate matches what we had at the time. We had arguments on both sides. No real new arguments. It's split among the community and it was split among the community. One thing we can do is make decorators make the choice of set vs defined. (@set)</p>
<p>DE: You might not want to use this when you are using a backing store i.e. in MobX.</p>
<p>DE: previous solution in decorators which didn't come up before in TC39 which is use a throwaway field, run the side-effect... I don't want to encourage this idiom. Unclear how JITs should reliably detect dead fields. This would encourage anti-patterns. This wasn't an issue in stage 0 because they were not about thinking the initializer.</p>
<p>DE: Instead, we could run a side effect outside of the decorator. Semantics decorators output can refrain from defining a field. We heard from the discussion of set and mobx that once the stage 2 was in babel, many people ran into this issue and proposed the mitigation and realized the flaws.</p>
<p>DE: Decoratator descriptor can have a <code>kind</code>: <code>&quot;initializer&quot;</code>. See semantics slide. Any thoughts on the initializer feature? PR in babel and wanted feedback from the committee. Thank you to everyone who participated in threads and reviews for this.</p>
<p>RBN: Mentioned in issue thread I have concerns that using the initializer in initializer description somewhat conflates it. It feels like we should have a different if you're not initializing a value.</p>
<p>DE: I misunderstood your review on the issue thread. What should the name be?</p>
<p>RBN: We discussed finishers?</p>
<p>DE: No these are different from finishers and we discussed that in the thread. Let's think about new names.</p>
<p>AK: So... say decorators went to stage 3 in July but then we realize something. Is there a reason we need this now vs later?</p>
<p>DE: It didn't pop up -- we had this a year ago as a proposal.</p>
<p>AK: If we think of something after, can we add to it?</p>
<p>DE: Yes, I hope in general we can get draft implementations and take that experimental feedback before going to stage 3. We decided not to add that to the process doc but I feel that's kind of the reason...</p>
<p>AK: Just because it isn't in a process document.</p>
<p>DE: Yes I want to do this and babel community stepped up and did it so want to help with that. We have stories for why we have certain mitigations. This one in particular we don't have data on the frequency but it seems we need this as a v1 feature to avoid anti-patterns. I want to be clear we should be open to follow up on proposals once decorators are out.</p>
<p>WH: My comment is very similar to RBN's. I too was confused by overloading the name &quot;initializer&quot;, wondering how initializing a nonexistent property works.</p>
<p>DE: Breakout session. We can talk about names?</p>
<p>KG: How about effect?</p>
<p>DE: two different things...</p>
<p>DE: Stage 2 update we have a line a communication with W3C tag. Positive reviews from W3C and frameworks. We are also improving docs and ongoing work in the babel's implementation. Thank you to the community who have done great work here.</p>
<p>DE: Minor spec updates... for the decorator ordering... in the previous breakout session, the conclusion I heard was there was rough consensus for export before decorator. I would be happy to conclude this. Based on comments I wanted to give other people a chance to propose to the agenda. It would benefit programmers. Export before decorator ordering... would love to get consensus.</p>
<p>RBN: I had issue with the breakout session discussion because people on the call weren't able to participate. Don't feel like there's full consensus yet.</p>
<p>DE: Where do you want to go from here?</p>
<p>RBN: In most discussions and the community and comment threads, it's a 50/50 split on the in favor of decorators before export? Doesn't seem locked in.</p>
<p>DE: How long do we need?</p>
<p>RBN: One more meeting?</p>
<p>DE: Let's agree to try and conclude that in the January meeting.</p>
<p>RBN: I am in favor of doing it right vs pushing it out.</p>
<p>DE: Let's discuss online.</p>
<p>MF: In private conversations with other members where decorators have really allowed advancement I have heard concerns that even though decorators are very popular, the general fit in the language and how it might affect the design of the language. Want to give the opportunity that is how they feel. I am not a fan decorators but I don't think it's harmful to the language. Community members who are in support of it, it seems there are groups who have taken advantage of the usage of it.</p>
<p>DE: Doesn't really correspond with my discussion with framework authors. It seems most of the framework authors are saying classes don't work well without decorators. That seems to be a broad opinion but can't say much. Would love to hear more and maybe even proposals for stage 2 earlier? Given where we are, want to hear about this.</p>
<p>MF: Yeah it seems people were agreeing for it but want to give opportunity. Since this is going to stage 3, it should be discussed.</p>
<p>??: To Ron's point, based on my experience, it doesn't seem the committee is going to help the proposal champions. I want Ron to be on the same page.</p>
<p>RBN: Yes.</p>
<p>DH: I want to timebox and champion to prevent issues coming along but I agree we don't need to spend more time debating with the committee.</p>
<p>WH: I am on the other side of the issue. I agree we have spent way too much time on this already. On another subject, speaking about our process in general, I'm a bit concerned about the push for more time for breakout sessions given that their topics are not announced in advance and the right people might not be there.</p>
<p>DE: I don't want to say breakout sessions were conclusive which is why I'm not saying stage 3 right now. My interest is getting this feature stabilized to stage 3 and it would benefit to users. I want to provide another call for MF's point. Please raise all concerns for stage 3. If not now then  prior to the next meeting.</p>
<p>AK: I would like to have a conversation more... since the next meeting we'd talk about stage 3? Light agenda?</p>
<p>MF: When does the committee not want a feature?</p>
<p>AK: It's stage 2. Committee expects this to become part of the language.</p>
<p>MF: There could be a case where more people than not the feature should be included in the language but nobody is passionate about blocking consensus.</p>
<p>DE: I don't think that's the feeling about decorators right now. This is a strong feature and my feeling is that the committee has been persuaded for decorators but want to hear more.</p>
<p>CM: Wanted to add some thoughts, I share MF's sense that the bunch of complexity to the language and I have a bias and I wouldn't bother this normally but as a committee member I feel everyone has had a chance to weigh in on it, we should be going ahead with it.</p>
<p>EFT: As one of the resident grease monkeys about this I want to hear more from implementers about the complexity and optimizability of this.... Nothing?</p>
<p>SGN: Decorators are not going to do a lot of harm for the runtime performance but startup performance. I'm trying to understand because committee members care about startup performance but this killing that...</p>
<p>DE: What is the baseline for this? To be concrete the performance overhead is that decorates allow you observe this thunk before the JIT kicks in. The other overhead is you can't see what is a private method vs field and that becomes more complex to do.</p>
<p>SGN: Looking at the spec it looks like this will kill static analysis.</p>
<p>DE: In transpiled decorated classes, we don't have any static analysis. Do you count decorated classes as the baseline? Or code that uses classes as the baseline.</p>
<p>SGN: The baseline should be non decorated classes.</p>
<p>AK: I have these concerns especially since we're talking about frameworks... I am not sure this is more of a footgun compared to using a framework.</p>
<p>MS: We have similar concerns in that static analysis will be difficult. We have to change the object model to account for decorators. I personally don't like it, users want it... startup cost i have concerns but not super huge.</p>
<p>EFT: My intuition is that when you codify this a first class language thing</p>
<p>DE: Because they are not able to use classes, they use an object literal. Decorators might be able to help with those and those aren't able to be static analyzed anyways.</p>
<p>Diego: We prefer these ergonomics of using decorators vs the current patterns. From a performance perspective, we have done our own tests with 10K-15K components, we have reached reasonable performance. For me the ergonomics outweigh the static analysis.</p>
<p>KS: It's clear people want to use it but you also have to ask if we had a similar conversation about JSX would we say the same thing? If Facebook was more assertive, would we have included JSX? I don't know the answer. More interested what other people think.</p>
<p>DE: I have arguments why decorators &gt; JSX.</p>
<p>JRL: One option we have is to leave it for babel and typescript. This can just become a syntax reservation for compilers to work on. If you shipped a decorator to a browser, it would throw because there's no runtime meaning to the decorator.</p>
<p>DE: I originally proposed that and we wanted to promote the unification so that we had interoperable code.</p>
<p>Diego: Yeah we talked about everyone would implement their own thing and we would have lots of interoperability.</p>
<p>TST:  I don't see the value of startup costs if the feature is valuable enough that it will lead to dynamic code that will lead to performance benefit.</p>
<p>SGN: Is that really the baseline then? Comparing against dynamic frameworks? Okay then let's ship this.</p>
<p>DE: Please let me know more issue.</p>
<a href="#conclusionresolution-decorators-stage-2-update"><h4 id="conclusionresolution-decorators-stage-2-update">Conclusion/Resolution</h4></a><ul>
<li>Decorator export issue conclude in January</li>
<li>Naming issue of initializer conclude in January (maybe breakout?)</li>
</ul>
<a href="#withdrawing-distinguishing-literal-strings"><h2 id="withdrawing-distinguishing-literal-strings">Withdrawing Distinguishing Literal Strings</h2></a><p>(Adam Klein)</p>
<ul>
<li><a href="https://github.com/mikewest/tc39-proposal-literals">proposal</a></li>
</ul>
<p>AK: I'm withdrawing a proposal I had a year ago. Trusted Types, which motivated it, has moved on to other ideas.</p>
<p>MM: What is WICG? Web Incubation Community Group</p>
<p>AK: There was some interest, but trusted types doesn't need it, so I'm not championing it anymore.</p>
<p>MM: I just mentioned that some of the purposes that serve that might be good purposes. Might be good to reintroduce that point.</p>
<p>DE: I share MM's interest. I'm presenting on it now.</p>
<a href="#conclusionresolution-withdrawing-distinguishing-literal-strings"><h4 id="conclusionresolution-withdrawing-distinguishing-literal-strings">Conclusion/Resolution</h4></a><ul>
<li>Withdrawn</li>
</ul>
<a href="#distinguishing-templates-pr-phase-1-spec-phase-2"><h2 id="distinguishing-templates-pr-phase-1-spec-phase-2">Distinguishing templates: PR Phase 1, Spec Phase 2</h2></a><p>(Daniel Ehrenberg)</p>
<ul>
<li><a href="https://github.com/tc39/ecma262/pull/1350">PR</a></li>
</ul>
<p>DE: I went to an annual conference where they talk about web standard proposals. Had the proposal of trusted types. History of what adam is talking and they heard tc39 would take a long time... that's disappointing. The direction they went in was instead of checking for literal strings, you had checks that would follow that policy that could sanitize strings of certain trusted types. I think what they were proposing with user configurable policies is complementary. Since the TPAC meeting, I think it would make sense to propose if we could do something here in tc39. I want make a way not for literal strings, checking if  a string is equal (what if one is literal and one isn't) but we don't need strings, templates is enough. Trusted types have a constructor so you have a trusted script source.</p>
<p>MM: What is that?</p>
<p>DE: Trusted types have a trusted script source where you can know it's from user code. You can make trusted templated script tag so people can check if something is a template literal. There is different levels to this -- embedder hooks, javascript API that can make this usable in developer code. Talking with Trusted type champions, they would be interested in having it in user land. It's nice for things to have a JavaScript API. I have 2 phases
Host hook
JavaScript API</p>
<p>DE: Is this a good approach? If useful for embedders, should we brand template objects to let embedders know they are template objects? Would we consider a javascript API for this? I split them in 2 separate phases because there are some concerns with integrity checks. If we want that, we don't want a monkey patch to spoof it. All functions are properties of objects but lots of things going down the pipeline i.e. proposal from apple to make built in modules or get originals web platform proposals. When we are familiar with more than one, we will know which direction to go.</p>
<p>WH: What are you trying to protect?</p>
<p>DE: We're making sure that new strings aren't manufactured through injection, but that they're actually represented by sourcetext in the JS. There was actually a tagged template with the source strings being in the sourcetext. Doesn't prove that the same tag is used but it does prove that there was some tag in literal source code. You're proving it was in the original source text vs HTTPS can prove it wasn't injected somehow.</p>
<p>WH: I don't understand what is being proposed here well enough to have a meaningful discussion about it. Maybe examples would help. What is allowed and not allowed?</p>
<p>DE: Trying to call trusted source string with a string it will throw an error. Perhaps something I can do is breakout... or make formal slides next time? Was there something that didn't make sense?</p>
<p>CM: I think explanations are farther ahead than where we are at.</p>
<p>JH: Execution point?</p>
<p>DE: We are not proving that template object was literally in source code?</p>
<p>JH: It sounds like you are trying to verify if a tag is from source code. Since it is frozen, we can guarantee that.</p>
<p>DE: There are further properties that would be nice but this matches the original request and isn't that bad.</p>
<p>KG: You mentioned JavaScript API which I think would be nice. API only useful if it's unforgeable... there are 3 things are not virtualizable -- Nan, undefined, infinity. Would the idea be introduce an unforgeable function?</p>
<p>DE: I like the import module. Regardless if we go with the Apple proposal to freeze modules, at least if we go... import map give you a place to virtualize built in modules.</p>
<p>KG: That seems reasonable. I thought this would end up a global.</p>
<p>DE: Yeah we discussed and we have raised concerns with virtualization. Import maps can give us a nice middle point.</p>
<p>BFS: I want to bring up a different design idea... concerns with global api when I think of something to be forged I think of typeof. Adding a new typeof is concerning... but it's the only thing proxies can't intercept. Has there been thought on the actual state of templates? Like how can we hang it off the object itself?</p>
<p>DE: I don't have any particular ideas what we can do in that area. We should chat if you have more ideas.</p>
<p>KG: Broader concern, which I don't think this should block stage 1 but: this is only useful in very restrictive CSP (content security policy) which restricts the use of eval and inline script tags, and scripts sourced from untrusted domains. Most sites using CSP get it very wrong. I am hesitant to add security features that are only a guarantee if some other thing is implemented correctly which most people do not implement correctly.</p>
<p>DE: Have you presented that to the trusted types group? We should do that.</p>
<p>KG: No we should though.</p>
<p>MM: Some of the motivations are good, but the particulars of this one are confused. I like the underlying motivation, though. The thing that needs to happen for clarity, it an articulation of a threat model. Chain of trust is the right concept.</p>
<p>DE: Okay so lack of documentation?</p>
<p>MM: Lack of documentation + general sense of this proposal is in the wrong direction.</p>
<p>DE I was hoping to defer to the trusted types proposal on that.</p>
<p>MM: I haven't looked into that proposal and I believe it does address they had something that addresses that proposal. I think there are a lot of corrupting assumptions.</p>
<p>DE: I am just trying to sift through.</p>
<p>MM: With trusted types, I'm not familiar with their requirements. Mike Samuel proposal about the threat model is something we should be concerned about.</p>
<p>DE: Perhaps we can talk offline because I don't understand the literalness of strings vs templates doesn't seem to be linked.</p>
<p>MM: The original threat model on eval mentioned something that might be a concern here. I agree we haven't documented the threat model.</p>
<p>JRL: Are you targeting tagged templates or normal template literals</p>
<p>DE: Tagged templates. Template literals are just strings</p>
<p>JRL: If we instead put this on the arguments object, we could capture all of these things as written in the program rather than just one use case for template literal. Whether it's an implicit from a tagged template, from a decorator, from a extensible literal, we can tell whether the caller was from source-text or from an unverified runtime call expression.</p>
<p>DE: That is an interesting idea, and we should think about that more. I think Justin from Polymer brought up this. This is a much more minimal idea to that—this is just tagging the template so embedders can read from it. KG mentioned but wanted to clarify this is a layering PR. They are not creating a concernable change but wanted to get broader feedback but doesn't truly need consensus. If we are just giving hooks to embedders.</p>
<p>MM: It is contentious.</p>
<p>DE: Want to pursue as a PR.</p>
<p>WH: This should go through the stage process.</p>
<p>MM: This gives hosts the ability to distinguish things that would otherwise be indistinguishable, thereby affecting the semantics of programs.</p>
<p>MF: I don't think this is an issue...</p>
<p>MM: I think we need to have a larger discussion. I don't want to encourage things that might break equivalency in embedders.</p>
<p>NHD: Talking about the comment Justin made, using arguments doesn't solve for template expressions.</p>
<p>JRL:It does solve the cases we are talking about if the trusted tag expression evaluates to a known class.. You'd have to bolt your own semantics to the known class. It just allows the tagged template function to know that I came from a tagged template source-text and not a call expression of the tagged template's function.</p>
<p>NHD: Okay, so, tangential.</p>
<p>RBN: Want to also touch about the arguments: in a way the template literals slot doesn't actually tell you it was passed to the actual template literal tag but it was just passed at some point. It sounds like it doesn't really solve the problem. What we really need is a mechanism that we have a trusted assumption call. This is also issue in decorators. We talked about possibilities of using a symbol that holds an access token so that when I call a decorator, so I can verify the call itself wasn't forged.</p>
<p>DE: I think this is interesting direction to look into to. I think this could be done as well as the arguments forging direction.</p>
<p>RBN: My concern is the slot is forgeable with or without eval. If I create a template literal and forge it then it will be a template literal.</p>
<p>DE: This isn't attempting to address that issue.</p>
<p>BFS: There's no API to construct a tagged template strings array.</p>
<p>NHD: In Handlebars we had a vulnerability which could in part be addressed by this. It has a construct called SafeString which was a POJO with a string property and a boolean stamp. If you had control over the JSON fed in, you could create an object that Handlebars would treat as a trusted string. Rather than stamping with a boolean property, we ended up replacing it with a function that returned true. This was a non-theoretical XSS vulnerability. This sort of stamp could be valuable to protect from this.</p>
<p>AK: I wanted to respond to Mark and Kevin... first off back up layering changes... we want to define well defined interactions rather than have a browser defining it on their own. If people are concerned about those changes, we shouldn't be doing that here because a layering change is a very small thing. One more thing, timelines... on average things take longer in tc39 than W3C, WICG, etc. It makes sense people get tired of waiting.</p>
<p>DE: We could provide useful input and I want to encourage two way interaction between other groups and TC39—want more input from web/node people in TC39 &amp; visa versa. That's why I mentioned W3C tag review. I want people to be able to bring problems to TC39 and not avoid it.</p>
<p>KG: If we in this room don't think a feature someone else is trying to implement.. It's true they might go around us, I still don't want to make changes.</p>
<p>DE: I'm not trying to champion the trusted types proposal. The literalness check is important.</p>
<p>KG: I don't think this change is a good idea.</p>
<p>WH: I am uncomfortable with this being a PR — this is a feature to solve an external use case rather than an internal refactoring change so it should go through the stage process.</p>
<p>DE: How should it go through it?</p>
<p>WH: Stage 1: should we discuss this? Stage 2: Do we think something like this will be added to the spec? ... We also need to discuss questions such as if it satisfies the threat model.</p>
<p>NSH: Is this ever going to be used? This enables people to write secure code but it's even better if people don't have to think about this. Is this primarily for people who are using for security? Anyway we can enforce URL rather than opt in?</p>
<p>DE: Do the headers help?</p>
<p>NSH: only if people use them.</p>
<p>MM: There is good work on formalizing JavaScript and you show things are equivalent by reasoning about semantic state. By adding an internal slot, you break transparency through proxies. Membrane transparency is a requirement.</p>
<p>BFS: I think we are skipping over how these template object arrays are a little string? The host could technically do things like source code manipulation... Do people really feel strongly of having these really strange object arrays and somehow preserving where they are in sourcetext.</p>
<p>MM: Yes.</p>
<p>BFS: How is an internal field different from callsite potency?</p>
<p>MM: I don't understand.</p>
<p>BFS: You can store strange internal state through side channels, so you have persistent state on this special object which can't be reproduced in a proxy..</p>
<p>KG: Let's take it offline.</p>
<a href="#conclusionresolution-distinguishing-templates-pr-phase-1-spec-phase-2"><h4 id="conclusionresolution-distinguishing-templates-pr-phase-1-spec-phase-2">Conclusion/Resolution</h4></a><ul>
<li>no consensus to merge the PR</li>
</ul>
<p>(Lunch break)</p>
<a href="#datestyletimestyle-for-stage-2"><h2 id="datestyletimestyle-for-stage-2">dateStyle/timeStyle for Stage 2</h2></a><p>(Daniel Ehrenberg)</p>
<ul>
<li><a href="https://github.com/tc39/proposal-ECMA-402-datetime-style">proposal</a></li>
</ul>
<p>DE: These are internationalization features and I'm just helping propose to stage 2. DateTimeFormat is currently locale-dependent style. dateStyle and timeStyle give you a more fine grained control and let you special narrow/short/medium/full. You can specify date, time or both</p>
<pre><code><span class="hljs-selector-tag">new</span> <span class="hljs-selector-tag">Intl</span><span class="hljs-selector-class">.DateTimeFormat</span>("<span class="hljs-selector-tag">en</span>", { <span class="hljs-attribute">timeStyle</span>: <span class="hljs-string">""</span>, dateStyle: <span class="hljs-string">""</span> });
</code></pre>
<p>DE: Using data present in CLDR exposed through ICU</p>
<p>DE: Updates since previous version -- data schema made well-defined, paralleling CLDR. When completely implementation defined we would take in OS preferences but it's actually based on the locale so removed that. Concluded to not read/check other options if dateStyle/timestyle set. Finally the <code>hourCycle</code>... it doesn't make sense to do timeStyle and then add for hourCycle... doesn't make sense to combine those so we are considering to honor that feature. (Slides have links to proposals)</p>
<p>DE: The Proposal status originally by Zibi is in stage 1. It is in Firefox internal only. Stage 2? Stage 3 reviewers? By the way this has been discussed and reviewed by ECMA 402 sub group and we are recommending to move to stage 2. Thoughts?</p>
<p>MF: General question if I am a website and I want to format things i.e. this... i would want to use a user preferred format. Is that available?</p>
<p>DE: It is not clear how to expose OS preferences. We've talked about browser preferences. We defer this to the site to manage.</p>
<p>MF: Is that a good thing?</p>
<p>DE: We are working little by little. We talk about the user-agent could provide this navigator.locales array of intl locale objects and maybe those locales could provide preferences but that leads to questions... i.e. its not clear we should keep growing existing extension mechanisms. I don't think this is the body to make that decision and ECMA 402 is been helping more with this. There isn't a clear way to make date/timeStyle. Also operating systems differ in their schemas.</p>
<p>MF: I want to make sure whatever format we do accept would be possible to provide via user agent.</p>
<p>DE: If we make an API to provide more specific strings, we ideally want to be able to pass navigator.locales instead of language string.</p>
<p>DE: This proposal is already set to accept intl.locales but the question of what could those be is still open. Ideally we get explicit data flow of options. One important use case is server use i.e. node.js ICU and INTL. Node.js made an effort to make these things available. It doesn't make sense to use OS options and they need to pass in via client.</p>
<p>MF: I'm not suggesting it be implicit but it should allow more user preferences to be consumed.</p>
<p>DE: We're thinking about best way to do it, unclear on when we will have proposal.</p>
<p>MF: Do you know if there is work currently for that?</p>
<p>FTG: if there already a way for OS to give preference, it can set it. If OS has a setting then that is an issue.</p>
<p>DE: Something that is still an issue is __. That slide shouldn't have a dot.</p>
<p>MF: I want a flexibility API to allow UA to pass the locale.</p>
<p>DE: That is an open-ended feature request.</p>
<p>FTG: What does the UA provided mean?</p>
<p>MF: If a user has preferences for date/time style and those preferences are quite specific...</p>
<p>FTG: I think we can definitely work on a different proposal to allow more formats to intl date format. This doesn't prohibit that.</p>
<p>MF: Satisfies me.</p>
<a href="#conclusionresolution-datestyletimestyle-for-stage-2"><h4 id="conclusionresolution-datestyletimestyle-for-stage-2">Conclusion/Resolution</h4></a><ul>
<li>Stage 2 acceptance</li>
<li>Stage 3 reviewers: FTG, NHD</li>
</ul>
<a href="#update-on-optional-chaining"><h2 id="update-on-optional-chaining">Update on Optional Chaining</h2></a><p>(Dustin Savery)</p>
<ul>
<li><a href="https://github.com/tc39/proposal-optional-chaining">proposal</a></li>
<li><a href="https://docs.google.com/presentation/d/12KG2Y1V6Ufa-ed1RsH6qC8S2nn0WFwY5bfBWHTaYJDY/edit?usp=sharing">slides</a></li>
</ul>
<p>DSY: I am now championing the optional chaining proposal after working through for the last 5 years. 2500 visitors and lots of traction on this proposal. Lot's of community involvement. A brief refresher for those who are not familiar -- syntactic sugar for finding a value in a tree-like structure. We want to simplify how we get a value out of a tree. We also want to deliver predictable results.</p>
<p>DSY:</p>
<pre><code>//<span class="hljs-keyword">with</span>
<span class="hljs-keyword">a</span>?.b?.c

<span class="hljs-keyword">a</span> == <span class="hljs-literal">null</span> ? undefined: <span class="hljs-keyword">a</span>.b == <span class="hljs-literal">null</span> ? undefined : <span class="hljs-keyword">a</span>.b.c
</code></pre>
<p>DSY: Lots of cleanliness with optional chaining and predictability. I want to be clear though there is we are not doing error prevention or logic alteration or augmentation. There is no sugar coating -- it's just an easier way to access a value in a tree. As far as what we are trying to support, we are proposing for property access including static and dynamic property access.</p>
<pre><code><span class="hljs-comment">//static</span>
<span class="hljs-keyword">const</span> x = a?.b;
<span class="hljs-comment">//dynamic</span>
<span class="hljs-keyword">const</span> y = a?.[<span class="hljs-string">'b'</span>];
</code></pre>
<p>DSY: What we don't support is: optional: function execution, deletion, construction, template literal, property assignment. Don't want to halt property access proposal because of this edge case.</p>
<p>DSY: Some controversy and lots of discussion but community has been supportive. Sticking point is particular operator to indicate optional access.</p>
<p>DSY: Right now we have <code>?.</code> and we chose this because other languages support this syntax i.e. C Sharp, swift, coffeescript. So obviously we don't want to jump bandwagon because other languages have been doing it but ultimate community support. If developers are using standard then it makes sense to continue using it. Looking at the polls, people are more supportive ?. syntax instead of other ones. If people have differing views, please let me know. I am not looking stage advancement but getting feedback and hearing concerns/wishes. I want people to agree that this proposal is worth advancing at a later date.</p>
<p>DSY: Where do we go from here? Hoping in March we can move this to stage 2 unless there are major hurdles.</p>
<p>WH: You just said optional chaining doesn't support function calls, but I just checked and they are in the proposal, both in the semantics and in the examples.</p>
<p>DSY: That's fair, there is a PR open to remove them which will be merged shortly, but I want to get feedback beforehand.</p>
<p>WH: Are you removing function calls anywhere in a optional chain (example: <code>a?.b()</code>), or only if directly following a <code>?.</code> (example: <code>a?.()</code>)?</p>
<p>DSY: The first example would be allowed, so the thing that is being removed is the optional function so if you <code>a?.()</code> It's confusing because of ternary operators—an edge case. But <code>a?.b()</code> is still valid.</p>
<p>WH: I am a little concerned but it might be okay.</p>
<p>DSY: Looking at the amount of complexity around it, it will cause problems. Community is primarily looking for property access.</p>
<p>JHD: Are we confident we'll never want optional calls?</p>
<p>DSY: No I don't think we will never want, but given the scope that is more of an edge case. If we can simply into smaller pieces we have a better change of moving forward.</p>
<p>JHD: This leads to something -- there is a lot of importance and value in having consistency in . and bracket access. If we want optional call in the future, it will need sufficient similarity to optional member access. I suspect many people will bring that up. I agree that separating optional call from member access is sensible but if we ship member access, we might corner ourselves for optional call. I don't have qualms about optional call but we need to assess the risk.</p>
<p>DSY: No, I think that's a good statement.</p>
<p>JHD: I have commented on the proposal repo I think it makes sense to me that we have a token and dot for member access and a token and a bracket... they should have the same token.</p>
<p>MM: Is there another concrete suggestion that would work in that situation?</p>
<p>JHD: <code>??</code> was floated around <code>??.</code> and <code>??[</code> but there would be consistency issues.. We wouldn't be to able to use it the other. Three question marks were distasteful to the group.</p>
<p>DE: We could use a triple bar, that only returns undefined.</p>
<p>JHD: There is a different discussion but I have an objection for null and undefined case.</p>
<p>DE: Does your objection also apply to defaults?</p>
<p>JHD: Yes I think it was an unfortunate choice for default parameters.. Null and undefined are indistinguishable in some cases but for default parameters they are.</p>
<p>DE: So one thing that's relevant—it might be a reason double question mark might be OK, but we're talking about triple bar.</p>
<p>JHD: Separate from semantic debate, if triple bar is generally acceptable then it seems like it would address the grammar issue and consistency issue. Nullish coalescing is intertwined with this.</p>
<p>BFS: I want to voice concerns about timing—we need consistency. We have a new operator .# for private fields, which doesn't have dynamic access. We're not blocking ability to access a private field. If we're not blocking we should explain need for consistency here and lack of consistency on private fields. Perhaps in future we can get private symbol to be used with dynamic access.</p>
<p>JHD: Someone stop me if someone has more knowledge about private class fields. As I have heard it explained, hash is part of the identifier, and <code>.#</code> is not an operator, so it's sufficiently different from public property access that the same expectations of similarity need not apply.</p>
<p>MA: BFS is pointing out that you don't have access to private fields</p>
<p>DE: Does that make it OK to not have this?</p>
<p>JHD: So yeah I think private fields are a different beast and the hash is part of the identifier... the lack of dynamic access for private fields... you can argue for that feature but the lack of it doesn't justify the lack of consistency.</p>
<p>WH: I agree with that.</p>
<p>BFS: My concern isn't you can or can't access priv fields dynamically. We are discussing a requirement before moving forward such as optional function, static access... we are not seeing the same discussion for private fields. I'm not concerned about private field accessor... we require one consistency one this proposal but we don't seem to require it on the other proposal.</p>
<p>RBN: I want to make the point for triple bar, when we look at double bar where we are doing boolean OR—would triple bar only care about undefined or would it also care about boolean values? It feels strange/doesn't feel like it's the right semantic for that syntax.</p>
<p>WH: In response to the question, we've had major discussions regarding private fields. We have explored that topic at length. Consistency has always been a design goal and there've been arguments.</p>
<p>JRL: Jordan brought up optional call would not have a similar syntax. My opinion it's different from optional property access because it's going to invoke a function. It could do typeof function, or is it nullish check only? As there are different semantics, it deserves a different syntax. The fact that it doesn't directly match is a good thing given they're different.</p>
<p>JHD: That seems reasonable to me.</p>
<p>DE: We have heard this consistency argument... how do we weigh that against what the community has to say.
Dave did lot's of outreach about this issue. Majority prefers <code>a?.</code> on GitHub, additionally framework maintainers voiced similar opinions. I think there are a multiple ways we can think about consistency. It's a hard pill to swallow but consistency with other programming languages -- lots of languages use '?.' Even among frameworks, i.e. Angular HandleBars... I don't think these arguments favor one or the other but there are tradeoffs. How should the committee weigh these?</p>
<p>WH: This proposal is mostly syntax driven — generated by the grammar for member expressions and call expressions. Those allow function calls already so we have to decide what to do with them regardless. The proposal as it is now (without the pending pull request) allows <code>?.</code> to apply to function calls the same way to square brackets. If we want to do steps to prevent that, we would be increasing the complexity of this proposal.</p>
<p>MM: the way people informally process text as opposed to the view from parsing—I can image even with the <code>?.[</code> property name being inconsistent with <code>?.</code> (where the consistent one would be <code>?..</code>). If you take a look at natural language, my sense is <code>?.</code> will come to mean optional chaining. I think ||| accepting null &amp; undefined as falsey is bad. If we think of it as stricter || which is about truthiness and falsiness, I would expect ||| to be stricter, ie. is is just about true and false. If we use ?. for null chaining and ?? for null coalescing, then there is a suggestiveness that the ? is about null/undefined as opposed to ||| being about truthiness. I think the former is more consistent &amp; better.</p>
<p>DS: Thanks for the discussion. Anyone have additional concerns, please discuss.</p>
<a href="#conclusionresolution-update-on-optional-chaining"><h4 id="conclusionresolution-update-on-optional-chaining">Conclusion/Resolution</h4></a><ul>
<li>Continue discussion more contact Dustin with thoughts</li>
</ul>
<p>(break)</p>
<a href="#editor-in-chief-selection"><h2 id="editor-in-chief-selection">Editor in Chief selection</h2></a><p>RJE: Aki will tell us how the voting process will work but if there is anything we need to discuss together please do.</p>
<p><em>Discussion ensues regarding editor in chief... Notes not taken during this section...</em></p>
<a href="#conclusionresolution-editor-in-chief-selection"><h4 id="conclusionresolution-editor-in-chief-selection">Conclusion/Resolution</h4></a><ul>
<li>Rules for voting will be posted on Reflector via picture.</li>
<li>Email Yulia your vote by tomorrow 12 PM</li>
</ul>
<a href="#asset-references-for-stage-1"><h2 id="asset-references-for-stage-1">Asset References for Stage 1</h2></a><p>(Sebastian Markbage)</p>
<ul>
<li><a href="https://github.com/sebmarkbage/ecmascript-asset-references">proposal</a></li>
</ul>
<p>SM: Goals of this is indirect dynamic import of relative path. Cross platform script authoring experience for assets... various bundlers can benefit from this.</p>
<p>SM: To refresh our memory on dynamic imports. The current stage 3 proposal which lets us load a different module on demand. However loading things over the network can get complicated such as showing a dialog on retry, etc. The loading experience makes it complicated.</p>
<p>SM: There's some problems with this. (1) if you extract to another file, you have to put a path relative to that other file, not your original file. This is the crux of the problem: libraries can't build this logic into separate files. (2) If you pass a dynamic path like a URL, packagers have this pseudo-syntax requirement where you provide a static string next to an import.</p>
<p>SM: Alternative for this is to wrap in it an arrow function and pass that arrow function into import.</p>
<p>MM: Where will this code appear?</p>
<p>SM: This code appears in __ source code and the library is what invokes this function. The library can define advanced syntax on when/where to load it, how to handle errors.</p>
<p>MM: I'm not understanding.</p>
<p>SM: Imagine this example instead of the load call taking a string, it takes an arrow function</p>
<pre><code>customLibrary(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'...'</span>));
</code></pre>
<p>SM: So now it's relative to the bottom (?) file.</p>
<p>SM: It's still not completely sufficient. (Shows slide title &quot;Alternative&quot; with reasons why it isn't sufficient.)
It does not let you talk to cache and doesn't work with other assets. We'd have to make you invent your own way to refer to things. It also doesn't allow additional argument configurations to loading. It kind-of looks awkward, for something this common to have an arrow function. And we're trying to require a conventional static string, but that's not being forced.</p>
<p>SM: Currently there exists capabilities to working with loaders i.e. require.cache but in Node.js they use require.cache[require.resolve(&quot;./other.js&quot;)];</p>
<p>SM: In WebPack, they behave more like pseudo-syntax. They require static strings.</p>
<p>MM: What does &quot;weak&quot; mean in this context?</p>
<p>SM: It means that this does not necessarily need to be in the same bundle as this file, but there could be an idiomatic check to see if the file is in the same bundle.</p>
<p>SM: The third one there is a theoretical loader API where we could do something like import.meta.resolveURL.</p>
<p>SM: Another use case is, where you have all kinds of resources, like images. There have been various ways to refer to images by relative paths. (Shows slide with prior art: Node.js, Webpack, Rollup, React Native, NativeScript, Web.)  But there's no canonical way to do this in JavaScript.</p>
<p>SM: Solution today? There is no canonical way but instead we use transpilers to translate. So a common thing is to use webpack to resolve dependency graph and then take the webpack bundle and run it. The problem is you can't use the language itself.</p>
<p>SM: So there are various ways we could approach this. We could build a whole ecosystem. But the smallest possible thing is that we need to get past this syntactical problem. We don't need runtime APIs, with polyfills, feature detection, etc. We just need the individual source files to be defined in a cross-platform way. The limitation today is there's no syntactic way to describe that.</p>
<p>SM: Static syntax we want</p>
<pre><code><span class="hljs-keyword">Import</span> asset Foo <span class="hljs-keyword">from</span> <span class="hljs-string">"foo.js"</span>;
</code></pre>
<p>SM: I think we also need the dynamic form still. This does not load the file. It just returns a promise that resolves into a reference to that file: (shows example code on slide).</p>
<p>SM: I'm not sure what data structure to use. Here is one option. It has 2 internal slots which are similar to dynamic import works. There is [ReferencingModule] and [AssetSpecifier]</p>
<p>MM: I'm sorry. Dynamic imports returns a promise, so what object has the internal slots?</p>
<p>SM: The internal function mechanism accepts these arguments and it has the same types.</p>
<p>MM: The dynamic import can accept something other than a string as an argument?</p>
<p>SM: No but when the call the internal mechanism (forget name), the imprort call calls an internal mechanism. That internal mechanism accepts __ and specifier that passes the string.</p>
<p>MM: So there's no observable object that has these as internal slots?  So you're saying there's ___ that has these internal slots?</p>
<p>SM: Yes. I'll get back to this. Might not be the right data structure.</p>
<p>SM: There is also dynamic import of reference where the specifier that was stored in this object. In this example it isn't based on the call site.</p>
<p>MM: I didn't follow that.</p>
<p>SM: Imagine this is two different files.</p>
<p>MM: The import line and the ___?</p>
<p>SM: In this proposal, the referencing module, the one with the import asset line, since it's attached to this first-class object, and the specifier is also part of this rarefied object...</p>
<p>MM: This would change the semantics of the dynamic import special form correct?</p>
<p>SM: Yes. So, one example is import.meta that contains this reified information.</p>
<p>SM: So the problem with this mechanism is that it allows you to use this mechanism in the runtime form. I can extract the URL from that and do my own resolution. With some mechanism in this library. Which is fine except that it doesn't have the static properties for build tools to use.</p>
<p>SM: Another alternative to having the syntax is to use the import.meta mechanism which is pretty much host environment can have whatever they want. I propose we had a resolveURL so that people can specify what loader they want. The problem is this only works on the web so we need to unify people on this extension and the particular usage of assets in the static form. But also the return value here in the request is very specific to the web. Maybe there will be a specific form that works for node as well. But it's a very heavy-weight object that it is hard to unify. But you could imagine that mechanism having opaque semantics. We could also leave this as-is and let bundlers modify using some pseudo-syntax and we keep cross-compiling between platforms. Or we could add a higher-level structure into the language.</p>
<p>MM: I think that this is adding a lot of mechanisms to both syntax and semantics around one of the worst thought out and newest features of the language which is dynamic import and import.meta. Both of these were allowed to proceed with the assumption that the Realm API would provide hooks to repair the unsafety. That hasn't converged yet and we don't fully understand how those hooks will work. You are trying to serve both bundlers and direct execution semantics in the absence of a bundler. You are trying to preserve the semantics with the absence of bundler. I like that. I sympathize with the goals here. I think dynamic imports and import.meta are some of the biggest mistakes we made and I don't want to consider adding more complexity to those mechanism until we figure those out.</p>
<p>SM: To your point, or to counter that point, the alternative is that there is going to be a process to add more things to import.meta if we don't do it in the web spec today, or bundlers will take advantage of import.meta because we open the door for host environments to add whatever they want. If we don't give a direction here, then clients will define their direction elsewhere.</p>
<p>MM: Like I said I sympathize with the goals but is there a way to address the goals without adding more weight to import.meta and dynamic import situation. I want to raise that as a design direction.</p>
<p>SM: So, in the current proposal, because this is the alternative, we don't add anything to import.meta. It does add to the ability to get one of these references into dynamic imports. And I think that can be staged at different levels b/c you can have loaders in the runtime that allow you to get a canonicalized specifier that can work for dynamic imports. A similar example is how do you actually use one of these objects in the web?  There would have to be some mechanism to extract the URL that could work with existing DOM APIs.</p>
<p>MM: In this special form, the logo variable comes down as...</p>
<p>SM: An asset preference object. What's added here is URL.createObjectURL, which creates this temporary URL reference to this opaque blob, which could be a URL or an in-memory representatoin.</p>
<p>MM: I  think I was just confused by the import.meta on your last slide. I misunderstood it to be part of the proposal. so it would have ..., a new data type, extend the dynamic import data type, anything else?</p>
<p>SM: No.</p>
<p>MM: Okay. In that case, I might not have an objection.</p>
<p>CM: Yeah so ergonomic nit, <code>import asset</code> is confusing because it is not importing anything but instead declaring a reference relative to the current context. I would just argue for a different keyword other than import asset.</p>
<p>SM: Yeah, so in the original proposal on GitHub, it's just asset without import. but that has potential grammar issues that we may need to solve. Maybe there's another word than &quot;Asset&quot; we could use. I also want to say, the reference for this is externally defined.</p>
<p>CM: The implication of import is you are importing but you are not. You are setting up to import in the future if you want, but it's not doing so.</p>
<p>SM: So, the mental model of the import statement is importing the bindings that are already defined elsewhere. This is importing the binding to a reference that is defined elsewhere.</p>
<p>Kevin: Maybe import ref?</p>
<p>MM: What is the API of the new data type?</p>
<p>??: Just a holder.</p>
<p>SM: I should explain more. There's concern when you create URLs to create representations, because they can't be garbage collected, so they have an unknown lifetime. Adding other mechanisms ... But it's weird you have 2 mechanisms. You can have an asset object and a reference object that behave similarly. Ideally it would look something like but which platform should it use? One idea we could use is that there is no asset reference defined in the language but the object behaves in a platform independent way.</p>
<p>MM: I would certainly want to look into it more deeply.</p>
<p>SM: Some issues... is this too much syntax? Is dynamic syntax enough? Some questions about resolution timing i.e. if there is a resolution timing it probably needs to be a promise... even just getting a canonicalized reference value needs to be a promise. Parameterized static syntax? I'm really just looking to see if we want to continue exploring this in TC39? To go to stage 1.</p>
<p>RJE: Objections to this going to Stage 1?</p>
<p>Kevin: The obvious problem is that there is a new opaque object. Can you elaborate on the justification for that?</p>
<p>SM: So in the language we have this string to represent the specifier that gets resolved later on. In the spec there is no canonicalized value that gets resolved as a string? Reason we don't do that is because of the garbage collection model -- once it becomes a string it becomes hard to clean it up. The other is that a string has all these security implications -- it cannot encourage you to manually manipulate it. If you look at Node.js it's a string but in webpack it is a number because it optimizes the transport so it doesn't have the long file type name. One possible alternative is a symbol, for example. But even that has garbage collection issues.</p>
<p>MM: Given this proposal, how strong a statement about the equivalence of the direct semantics to the semantics of static...</p>
<p>SM: For the static proposal, so if we're talking about only the &quot;static syntax&quot; form, because the string itself is not observable at runtime, statically resolved early on, even if there's a more filesystem requirement when resolving... in the dynamic syntax form, it's different. It's similar to how the dynamic import system does not have equivalency, unless you have the requirement that the argument passed in must be a static string.</p>
<p>AK: So I am relaying with dominic and he gave me a quick statement. I think this is a good problem space to explore but we need to iron out before stage 2. I think there's support for stage 1 but want to relay those thoughts.</p>
<a href="#conclusionresolution-asset-references-for-stage-1"><h4 id="conclusionresolution-asset-references-for-stage-1">Conclusion/Resolution</h4></a><ul>
<li>Stage 1 acceptance</li>
<li>Some thoughts to iron out before approval to stage 2 see proposal thread</li>
</ul>
<a href="#isregexp-change"><h2 id="isregexp-change">isRegExp change</h2></a><p>(Jordan Harband)</p>
<ul>
<li><a href="https://github.com/tc39/ecma262/pull/1318">proposal</a></li>
</ul>
<p>JHD: So the current isRegExp algorithm are used in 4 places and 3 of them are used for throwing an error.. What the algorithm does is it returns true if it has a regex slot. It has an additional case though which I will talk about later. If isRegExp returns true, it looks up its source and flag properties, to otherwise it treats as a string and stringifies it, and constructs a regex from the string.</p>
<p>JHD: If it has an undefined symbol.match value and the internal slot, isRegExp will return true. What this means... out of the 4 symbols, one of them is special and denotes isRegExp. I asked Allen on the PR what the motivation was: it was the simplest one and it seemed easy, and there was mild pushback about checking more than one symbol. What this attempts to do is remove Symbol.match from isRegExp. This will remove an observable call. Negative impact it could have is if someone was currently passing into <code>new RegExp</code> an object, that was not a true regex nor <code>extends RegExp</code>, with a <code>Symbol.match</code> property, and instead of reading its source and flags properties, would stringify and lead to a different result. I am very skeptical that people are doing that. If you subclassed RegExp you'd be fine, whether you'd overridden Symbol.match or not, and it doesn't make sense to me to subclass RegExp if you want the RegExp constructor to treat your instances as &quot;not a regex&quot;.</p>
<p>JHD: It will be better to have a clear precedent and clear mental model of how regex symbols work. I wanted to get consensus between one of the 2 approaches -- one in the PR which is removing the symbol.match check, and an alternative to checking for any of the regex symbols (which would likely have a performance impact). I think we can easily add a use counter in Chrome to detect how often this happens. If we can't make a consensus because it isn't web compatible or pushback on implementation, that's fine, but it would help future designs and matchAll if we can decide what makes the most sense - what we would want conceptually. Symbol.match being special allows for ambiguous interpretations of its behavior.</p>
<p>DE: I support this proposal. I don't quite understand one symbol being different from the other but why I like about this to subclass regex -- taking that motivation there is a use case where you can port the exec command and that was a design goal from allen and that would be preserved.</p>
<p>AK: There is a lot of text from Allen about this.</p>
<p>DE: Do you want to represent allen's concerns.</p>
<p>JHD: Yeah sure so Allen's comments -cites from github PR-. You could make a subclass of regex and mark it not a regex but no one has claimed a use case for that I'm aware of.</p>
<p>DE: I believe Brendan and Yehuda remember this conversation?</p>
<p>BE: I'm a little worried about the complexity of the RegExp design.</p>
<p>DE: Yeah we are concerned too but we want to know if it's okay to proceed.</p>
<p>MM: I certainly participated -- I don't think I have enough memory but Allen's general approach to the kinds of questions, Smalltalk made very intimate use of such subclass inheritance override patterns. The yo-yo people have complained about is related. Allen tried to make Regex economically subclassable.</p>
<p>DE: That makes sense -- do you see this PR making regex less economically subclassable.</p>
<p>MM: I don't know. I can see how Allen's intuition would lead to this but I can't simulate Allen well enough to predict whether he would object to this change.</p>
<p>DE: He did object to it.</p>
<p>MA: When we were implementing regex subclassing. There is the exec level... we tripped over this originally. I have a concern that this fix may affect the optimizations we have done based on how ES6 made regexes.</p>
<p>MM: The Allen design approach from Smalltalk regarding subclassing make patterns that are very hard to optimize.</p>
<p>MA: We had to do a lot of checks...</p>
<p>DE: Chrome also.</p>
<p>AK: We had feedback from V8 and they said they were happy with the PR.</p>
<p>JHD: If we get implementation feedback that would push back which solution would we opt for? I'm not interested in slowing down regexes but if we can agree to remove this check, I can move forward with other proposals.</p>
<p>Kevin: I can see the point of view from Allen's design -- does this change have any benefits to match all?</p>
<p>JHD: 4 regex symbols 2 have fallback behavior and the other 2 have different fallback behavior. The match all currently would seem to suggest it isn't special but in my proposal, I believe it is special and this would actually help clarify.</p>
<p>DE: So we are saying due to web reality this may be an issue but if it isn't we can proceed with match all.</p>
<p>JHD: if removing the check has consensus then we could move forward and I'm hoping the outcome will be to move matchAll through with the mental model we have and onward to stage 4.</p>
<p>JHD: I'm going to establish web compatibility and adding use counter</p>
<p>SGN: I have concerns about the use counter due to performance.</p>
<p>MB: We've taken the temporary perf hit in the past just to get the data.</p>
<p>JHD: I want to proceed with the <code>matchAll</code> proposal.</p>
<p>JRL: The only place this would have a performance hit is where you pass a regexp without the <code>@@match</code> property to the regexp constructor. The other cases all raise an error, so it wouldn't impact performance.</p>
<p>JHD: I really want to proceed with <code>matchAll</code>.</p>
<p>SGN: Okay that sounds good.</p>
<p>JHD: Okay thank you everybody..</p>
<a href="#conclusionresolution-isregexp-change"><h4 id="conclusionresolution-isregexp-change">Conclusion/Resolution</h4></a><ul>
<li>PR will move forward and JHD will revisit to check web compatibility and maybe implement a use counter (seems no performance issue) and unlikely but good to check</li>
<li>JHD can move forward with matchAll proposal with the conception that symbol check shouldn't be happening, regardless of whether removing the check is able to land or not.</li>
</ul>

</body>